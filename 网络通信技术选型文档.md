# 网络通信技术选型文档：WebSocket vs WebRTC

## 文档概述

本文档记录了在 Godot 3D 萌宠项目中关于网络通信技术的选型讨论，包括 WebSocket 与 WebRTC 的对比分析，以及主流游戏（英雄联盟、王者荣耀等）的通信架构研究。

**文档版本**：v1.0  
**最后更新**：2024  
**适用项目**：godot-pet (Godot 客户端) + q_llm_pet (JS 服务端)

---

## 1. WebRTC vs WebSocket：基础对比

### 1.1 底层协议的本质区别

| 特性 | WebSocket | WebRTC (DataChannel) |
| :--- | :--- | :--- |
| **传输协议** | **TCP** | **UDP** (通常) |
| **交付保证** | 强可靠性（不丢包、按序到达） | 可选：可靠 或 **不可靠**（丢包不重传） |
| **延迟特性** | 存在 **队头阻塞 (HOL Blocking)** | **极低延迟**，无队头阻塞 |
| **连接模式** | 客户端-服务器 (C/S) | 点对点 (P2P) 或 客户端-服务器 |
| **浏览器支持** | 所有现代浏览器 | 所有现代浏览器 |
| **实现复杂度** | 简单 | 中等（需要信令服务器） |

### 1.2 为什么 WebRTC 在某些场景"更好"？

#### A. 极低的延迟（Latency）

**WebSocket (TCP) 的问题：**
- 如果一个数据包在网络中丢失，TCP 会停止后续所有包的发送，直到丢失的包被重传成功
- 这在网络不稳定时会导致明显的"卡顿"和延迟累积
- 存在**队头阻塞 (Head-of-Line Blocking)** 问题

**WebRTC (UDP) 的优势：**
- 在"不可靠"模式下，如果一个包丢了，程序会直接处理下一个最新的包
- 对于萌宠的位置同步、动作指令，**"最新的位置"永远比"补发的旧位置"更重要**
- 无队头阻塞，延迟极低（通常 < 50ms）

#### B. 原生支持多媒体（音视频）

**WebSocket：**
- 只能传输二进制流或文本
- 如果想让萌宠通过语音实时说话，需要自己处理音频编码、解码、缓冲同步等复杂逻辑
- 需要额外的音频处理库和同步机制

**WebRTC：**
- 原生内置了对实时音视频流的支持（SRTP）
- 拥有成熟的抖动缓冲（Jitter Buffer）和回声消除算法
- 能提供电话级别的沟通体验
- 支持视频流传输（未来可扩展为视频通话）

#### C. 网络穿透与 P2P

**WebRTC 的优势：**
- 允许两个客户端直接通信（P2P），无需经过服务器转发
- 不仅能减少服务器带宽成本，还能进一步降低物理距离带来的延迟
- 内置 ICE (Interactive Connectivity Establishment) 协议，自动处理 NAT 穿透

**WebSocket 的限制：**
- 必须通过服务器中转
- 所有数据都要经过服务器，增加延迟和带宽成本

### 1.3 技术组合建议

在实际的高端项目中，通常会**同时使用**：

- **WebSocket**：用于信令（Signaling）交换和关键逻辑下发
- **WebRTC**：用于高频数据（坐标、物理状态）和媒体流同步

这种混合架构能兼顾可靠性和实时性。

---

## 2. 针对"萌宠项目"的选型建议

### 2.1 场景一：使用 WebSocket (当前推荐)

**优点：**
- ✅ 实现简单，开发成本低
- ✅ 防火墙兼容性好（几乎所有网络环境都支持）
- ✅ Node.js 对 WebSocket 支持极其成熟（`ws` 库）
- ✅ 调试方便（可以直接用浏览器开发者工具查看消息）
- ✅ 适合文本和 JSON 数据传输

**适用场景：**
- 文字对话（LLM 交互）
- 状态更新（能量、无聊度）
- 低频指令执行（"跳舞"、"睡觉"等动作指令）
- 聊天消息传输

**结论：**
对于目前的 LLM + 行为树逻辑，WebSocket 已经能提供非常好的体验。LLM 生成回复的速度通常在几百毫秒甚至几秒，网络延迟（几毫秒）在 LLM 的响应时间面前微不足道。

### 2.2 场景二：升级到 WebRTC (进阶需求)

**优点：**
- ✅ 交互感"丝滑"，支持实时语音
- ✅ 在弱网环境下表现更好
- ✅ 支持 P2P 直连，减少服务器压力

**适用场景：**
1. **高频物理同步**：如果希望在 Web 端拖拽萌宠，Godot 端能几乎零延迟地看到位移（类似云游戏）
2. **语音交互**：直接通过麦克风和萌宠说话，它实时语音回复
3. **多端实时协作**：多个人同时在不同的屏幕上操控同一只宠物，且需要极高的同步率
4. **视频流传输**：未来如果需要萌宠"看到"用户（通过摄像头）

**实现复杂度：**
- 需要额外的信令服务器（用于建立 WebRTC 连接）
- 需要处理 NAT 穿透和网络适配
- 调试相对复杂

### 2.3 当前阶段建议

**考虑到 Godot 和 JS 端的开发效率，建议先用 WebSocket 跑通逻辑。**

如果未来发现以下问题，再考虑引入 WebRTC：
- 动作同步有明显的滞后感（延迟 > 100ms）
- 需要加入实时语音对讲功能
- 需要支持多客户端实时协作
- 需要传输视频流数据

---

## 3. 主流游戏的通信架构研究

### 3.1 英雄联盟、王者荣耀等竞技游戏用什么？

**核心答案：它们绝不使用普通的 WebSocket 或 TCP，而是使用基于 UDP 的"可靠 UDP"协议 (Reliable UDP, 简称 RUDP)，配合"帧同步"或"状态同步"技术。**

#### A. 底层协议：UDP 的"定制化" (RUDP)

虽然 UDP 丢包不重传，但游戏里的某些数据（比如你买了一件装备）是绝对不能丢的。所以，这些游戏开发了自己的 **RUDP** 协议：

**王者荣耀 / 原神：**
- 在移动端，腾讯和米哈游广泛使用 **KCP** 协议（或者类似的自研协议）
- KCP 是一个基于 UDP 的算法，它能在牺牲少量带宽的情况下，比 TCP 快 30%-40% 地下发数据
- 针对移动网络（4G/5G）的不稳定性做了大量优化

**英雄联盟 (PC)：**
- 使用 Riot 自研的基于 UDP 的协议
- 由于 PC 网络相对稳定，它更侧重于**数据包的聚合和加密**，以防止外挂和减少网络抖动
- 使用自定义的可靠传输层，确保关键数据不丢失

**和平精英 / PUBG：**
- 使用自研的 RUDP 协议
- 针对射击游戏的特性，对位置同步做了大量优化（预测、插值、回滚）

#### B. 核心同步技术：帧同步 (Frame Sync)

这是《王者荣耀》这类 MOBA 游戏的核心技术。

**原理：**
- 服务端并不告诉客户端"韩信现在在坐标 (100, 200)"
- 而是告诉所有客户端："在第 500 帧，韩信按下了 1 技能"
- 所有客户端在同一帧执行同样的动作，保证逻辑一致性

**优点：**
- 传输的数据量极小（只传按键指令，不传位置）
- 所有客户端逻辑完全一致，防止外挂
- 支持回放和断线重连（只需要重放指令序列）

**缺点：**
- 对延迟（Ping值）极其敏感
- 如果网络抖动，所有玩家都会"飘"起来
- 这就是为什么你在打王者时，Ping 值一旦跳到 200ms，全场的人都会卡顿

#### C. 为什么它们不直接用 WebRTC？

**开发年代原因：**
- LoL 这种游戏核心引擎开发于 15 年前，那时候 WebRTC 还没影子
- 王者荣耀的核心架构也早在 WebRTC 成熟之前就定型了

**可控性：**
- 大厂需要对协议拥有 100% 的控制权
- 比如在 5G 信号弱时如何自动降级，在 Wi-Fi 抖动时如何切换路径
- WebRTC 是一个通用的标准，虽然强大，但对于追求极致性能的游戏来说，**"自研 RUDP"** 更有弹性

**平台限制：**
- 这些游戏主要在原生平台（iOS/Android/PC）运行，可以直接使用底层 UDP
- 不需要考虑浏览器的限制

### 3.2 网游通信的"三层塔"架构

如果我们要拆解《王者荣耀》的通信，它看起来是这样的：

| 层级 | 协议类型 | 具体用途 | 延迟要求 |
| :--- | :--- | :--- | :--- |
| **1. 大厅与结算层** | HTTPS / TCP | 登录、抽奖、看商城、匹配队友 | 可接受几百毫秒 |
| **2. 战斗指令层** | RUDP / KCP | 释放技能、走位、物理碰撞 | 要求 < 50ms |
| **3. 语音通话层** | VoIP / WebRTC | 局内开麦和队友沟通 | 要求 < 100ms |

**关键点：**
- 不同场景使用不同的协议，而不是"一刀切"
- 关键逻辑（战斗）用 UDP，非关键逻辑（商城）用 TCP
- 语音通常直接集成第三方 SDK（如腾讯 GME），其底层就是类似 WebRTC 的技术

### 3.3 网页游戏的特殊情况

**为什么网页游戏以前体验差？**

- 浏览器不支持原生的 UDP 或 ENet
- 以前只能用 WebSocket (TCP)，导致高频操作的网页游戏体验很差
- 这就是为什么以前网页版的《英雄联盟》或《王者荣耀》几乎不存在

**WebRTC 的出现改变了什么？**

- WebRTC 本质上是**"能在浏览器里运行的 UDP"**
- 网页端终于能实现类似端游的 UDP 极速体验
- 现在一些网页游戏（如《Roblox》、《Fortnite 网页版》）已经开始使用 WebRTC

---

## 4. 回到萌宠项目：最终选型

### 4.1 项目特点分析

**当前架构：**
- **服务端**：JS (Node.js) + 行为树 + LLM
- **客户端**：Godot 3D + Web 端（React Three Fiber）

**核心逻辑：**
- LLM 生成回复的速度通常在几百毫秒甚至几秒
- 行为树决策通常按秒级更新
- 动作指令下发频率：每秒 1-10 次
- 位置同步频率：每秒 5-20 次（可选）

**网络延迟影响：**
- LLM 响应时间：500ms - 3000ms
- WebSocket 延迟：< 100ms
- **网络延迟在 LLM 的响应时间面前微不足道**

### 4.2 选型结论

**推荐方案：WebSocket**

**理由：**
1. ✅ **开发效率高**：Node.js 的 `ws` 库非常成熟，Godot 也原生支持 WebSocket
2. ✅ **性能足够**：对于 LLM + 行为树的场景，WebSocket 的延迟完全可以接受
3. ✅ **调试方便**：可以直接用浏览器开发者工具查看消息
4. ✅ **跨平台兼容**：Web 端和 Godot 端都能轻松支持
5. ✅ **实现简单**：不需要额外的信令服务器和 NAT 穿透逻辑

**何时考虑升级到 WebRTC：**
- 如果需要实现"用鼠标实时拽着萌宠甩来甩去"，且要求 Web 端和 Godot 端看到的动作完全同步
- 如果需要加入实时语音交互功能
- 如果需要支持多客户端实时协作（多人同时操控）
- 如果发现 WebSocket 在弱网环境下有明显延迟问题

### 4.3 Godot 的优势

**Godot 的网络模块设计得非常好：**
- `MultiplayerAPI` 允许你切换底层连接方式（ENet, WebSocket, WebRTC）而不需要大幅改动上层业务代码
- 如果未来需要升级，只需要修改连接配置，业务逻辑基本不变

**如果未来需要极致性能：**
- Godot 支持 `ENet`（高性能 RUDP 库）
- 可以直接在 Godot 端使用 ENet，服务端使用 Node.js 的 `enet` 库
- 但这需要放弃 Web 端支持（浏览器不支持 ENet）

---

## 5. 总结对比表

| 维度 | WebSocket | WebRTC | 游戏 RUDP (KCP/ENet) |
| :--- | :--- | :--- | :--- |
| **延迟** | 中等 (50-200ms) | 极低 (< 50ms) | 极低 (< 20ms) |
| **可靠性** | 高（不丢包） | 可选（可丢包） | 可选（可丢包） |
| **实现复杂度** | 低 | 中 | 高 |
| **浏览器支持** | ✅ 完美 | ✅ 完美 | ❌ 不支持 |
| **跨平台** | ✅ 是 | ✅ 是 | ❌ 否（需原生） |
| **适用场景** | 文本/JSON 传输 | 实时音视频/高频数据 | 竞技游戏战斗逻辑 |
| **萌宠项目** | ✅ **推荐** | ⚠️ 可选（进阶） | ❌ 不适用 |

---

## 6. 参考资料

- [WebSocket 协议规范 (RFC 6455)](https://tools.ietf.org/html/rfc6455)
- [WebRTC 规范 (W3C)](https://www.w3.org/TR/webrtc/)
- [KCP 协议文档](https://github.com/skywind3000/kcp)
- [Godot 网络文档](https://docs.godotengine.org/en/stable/tutorials/networking/)
- [Node.js WebSocket 库 (ws)](https://github.com/websockets/ws)

---

**文档版本**：v1.0  
**最后更新**：2024  
**维护者**：开发团队
