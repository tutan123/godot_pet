# 动作逻辑职责划分：本地状态机 vs 服务端行为树

在本项目中，我们采用了 **“本地身体（表现层）+ 服务端大脑（决策层）”** 的混合架构。为了确保交互的实时性和逻辑的复杂性，我们将动作控制划分为两个层次：

## 1. 职责划分核心原则

| 层次 | 归属 | 核心技术 | 职责描述 |
| :--- | :--- | :--- | :--- |
| **表现层 (Body)** | Godot 客户端 | 状态机 (AnimationTree) + 程序化动画 | 负责动画播放、平滑过渡、实时物理反馈（重力、碰撞、拖拽）。 |
| **决策层 (Brain)** | JS 服务端 | 行为树 (Behavior Tree) + LLM | 负责意图理解、复杂逻辑判断、生存状态管理（能量、情绪）、长期规划。 |

---

## 2. 为什么本地使用“状态机”？

Godot 本地不使用行为树，而是使用 **状态机 (State Machine)**，原因如下：

1.  **极高实时性**：行走、奔跑、跳跃等动作需要每一帧都与物理引擎同步。状态机（Godot 的 `AnimationTree`）在 C++ 层执行，性能极高。
2.  **平滑过渡**：状态机擅长处理动画之间的 Crossfade（交叉淡入淡出），能保证企鹅从“走”到“停”的动作切换自然。
3.  **预测性**：物理状态（如“在地上”、“在空中”、“被撞击”）是确定性的，适合用有限状态机管理。
4.  **低级指令执行**：客户端的角色本质上是一个“指令接收器”。它不需要思考“为什么要走”，只需要处理“怎么走得漂亮”。

---

## 3. 为什么服务端使用“行为树”？

JS 服务端承担了所有“智力”工作，使用 **行为树 (Behavior Tree)** 的优势在于：

1.  **逻辑可扩展性**：行为树非常适合处理“如果...那么...否则...”的复杂组合逻辑，比状态机更易于维护和扩展（特别是接入 LLM 后）。
2.  **异步友好**：行为树天生支持“等待（Wait）”、“顺序执行（Sequence）”和“并行执行（Parallel）”，非常适合处理 LLM 生成的动作序列。
3.  **统一权威性**：所有客户端看到的是同一个“大脑”决策的结果，保证了状态的一致性。
4.  **环境感知（Blackboard）**：服务端通过“黑板系统”收集所有环境信息（位置、用户输入、碰撞事件），从而做出全局决策。

---

## 4. 关键交互流程：以“拖拽”为例

虽然拖拽由本地控制，但数据流向如下：

1.  **捕获输入**：Godot 检测到鼠标点击，本地**状态机**立即进入 `JUMP` 或 `DRAG` 姿态（保证零延迟反馈）。
2.  **同步信号**：Godot 发送 `interaction: drag_start` 给 JS。
3.  **黑板更新**：JS 服务端的黑板设置 `isDragging = true`。
4.  **决策响应**：JS 的行为树检测到 `isDragging`，可能会中断当前的自动寻路，转而下发一个 `EXPRESSION: PANIC`（慌张表情）的指令。
5.  **反馈闭环**：Godot 接收到表情指令，在本地播放慌张动画。

---

## 5. 环境状态同步 (Blackboard Sync)

为了让“大脑”更准，客户端需要持续向服务端上报状态：

*   **位置同步 (Position)**：JS 端黑板必须实时知道机器人的位置。如果机器人走到了“悬崖边”（通过位置坐标判断），行为树的 `BlackboardGuard` 节点会拦截前进指令，防止“掉落”。
*   **物理反馈 (Physics)**：当本地检测到碰撞时，上报 `collision` 事件。服务端大脑收到后，可以触发“喊疼”或“后退”的逻辑。
*   **状态回传**：服务端计算的能量（Energy）消耗会推送到客户端 UI 显示。

## 6. 总结：谁是大脑？谁是身体？

*   **JS 服务端是“战略层”**：它决定“去做什么（What to do）”。
*   **Godot 客户端是“战术层”**：它决定“怎么表现（How to perform）”。

这种划分模式兼顾了 **3D 渲染的高性能** 和 **AI 决策的高灵活性**。
