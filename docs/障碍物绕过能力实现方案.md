# 障碍物绕过能力实现方案

## 问题描述

角色在尝试移动到目标位置（如小球）时，可能会卡在障碍物边缘（如长方形舞台的边缘），无法继续前进。当前系统缺乏：
1. **卡住状态检测**：无法判断角色是否被障碍物阻挡
2. **自动绕过逻辑**：不会自动执行跳跃+前冲来绕过障碍物
3. **服务端感知**：服务端不知道客户端角色卡住了

## 系统架构分析

### 当前架构

```
┌─────────────────┐         WebSocket          ┌─────────────────┐
│   客户端 (Godot) │ ◄────────────────────────► │  服务端 (Node.js) │
│                 │                             │                 │
│ - 物理引擎       │                             │ - 行为树 (BT)    │
│ - 碰撞检测       │                             │ - EQS 查询       │
│ - 移动控制       │                             │ - AI 决策        │
│ - 战术跳跃       │                             │                 │
└─────────────────┘                             └─────────────────┘
```

### 关键组件

#### 客户端 (Godot)
- **pet_controller.gd**: 主控制器，协调各模块
- **pet_physics.gd**: 物理模块，包含战术跳跃系统 (`jump_push_pending`)
- **pet_messaging.gd**: 消息模块，负责与服务端通信
- **eqs_adapter.gd**: EQS适配器，执行环境查询

#### 服务端 (Node.js/TypeScript)
- **BTServer.ts**: 行为树服务器，处理WebSocket通信
- **MoveToNode.ts**: 移动节点，执行移动指令
- **EQSQueryNode.ts**: EQS查询节点，执行环境查询
- **ServerEQS.ts**: EQS服务端逻辑

## 解决方案设计

### 方案一：客户端检测 + 服务端决策（推荐）

**核心思路**：客户端检测卡住状态并上报，服务端收到后触发绕过逻辑。

#### 优点
- 服务端可以统一决策，利用EQS查询找到最佳绕过路径
- 客户端只需负责检测和上报，逻辑简单
- 可以结合LLM决策，让AI"思考"如何绕过

#### 缺点
- 需要双向通信，有延迟
- 服务端需要实现绕过逻辑

### 方案二：客户端自主绕过

**核心思路**：客户端检测到卡住后，自动执行跳跃+前冲。

#### 优点
- 响应速度快，无网络延迟
- 实现简单，不需要服务端改动

#### 缺点
- 客户端逻辑复杂，可能绕过失败
- 无法利用服务端的EQS查询能力
- 可能与服务端指令冲突

## 推荐实现：方案一（混合方案）

结合两种方案的优点：
1. **客户端**：检测卡住状态，上报给服务端
2. **服务端**：收到卡住状态后，使用EQS查询找到绕过路径，或直接触发战术跳跃
3. **客户端**：执行服务端的绕过指令（跳跃+前冲）

## 详细实现步骤

### 第一步：客户端 - 卡住状态检测

**文件**: `GAME/godot-pet/scripts/pet_physics.gd`

#### 1.1 添加卡住检测变量

```gdscript
# 卡住检测相关变量
var stuck_detection_enabled: bool = true
var stuck_check_interval: float = 0.5  # 每0.5秒检查一次
var stuck_check_timer: float = 0.0
var last_position: Vector3 = Vector3.ZERO
var stuck_threshold: float = 0.1  # 0.1米内视为卡住
var stuck_duration: float = 0.0  # 卡住持续时间
var stuck_timeout: float = 2.0  # 2秒后认为卡住
var is_stuck: bool = false
var stuck_normal: Vector3 = Vector3.ZERO  # 障碍物法线方向
```

#### 1.2 实现卡住检测函数

```gdscript
## 检测角色是否卡住
func check_stuck(character_body: CharacterBody3D, delta: float) -> Dictionary:
    if not stuck_detection_enabled:
        return {"is_stuck": false}
    
    stuck_check_timer += delta
    
    # 只在移动时检测
    if not is_server_moving and not is_moving_to_click:
        stuck_check_timer = 0.0
        stuck_duration = 0.0
        is_stuck = false
        return {"is_stuck": false}
    
    # 定期检查位置变化
    if stuck_check_timer >= stuck_check_interval:
        stuck_check_timer = 0.0
        
        var current_pos = character_body.global_position
        var horizontal_movement = Vector2(
            current_pos.x - last_position.x,
            current_pos.z - last_position.z
        ).length()
        
        # 如果水平移动距离小于阈值，认为可能卡住
        if horizontal_movement < stuck_threshold:
            stuck_duration += stuck_check_interval
            
            # 检查是否有侧向碰撞（障碍物）
            var has_obstacle = false
            var obstacle_normal = Vector3.ZERO
            
            for i in range(character_body.get_slide_collision_count()):
                var collision = character_body.get_slide_collision(i)
                var normal = collision.get_normal()
                
                # 检查是否是侧向碰撞（不是地面）
                if normal.y < 0.7:  # 不是地面
                    has_obstacle = true
                    obstacle_normal = normal
                    break
            
            # 如果卡住时间超过阈值，且检测到障碍物，确认卡住
            if stuck_duration >= stuck_timeout and has_obstacle:
                if not is_stuck:
                    is_stuck = true
                    stuck_normal = obstacle_normal
                    print("[Physics] Character is STUCK! Normal: %s" % stuck_normal)
                    return {
                        "is_stuck": true,
                        "position": [current_pos.x, current_pos.y, current_pos.z],
                        "normal": [stuck_normal.x, stuck_normal.y, stuck_normal.z],
                        "target": [target_position.x, target_position.y, target_position.z]
                    }
        else:
            # 有移动，重置卡住状态
            stuck_duration = 0.0
            is_stuck = false
        
        last_position = current_pos
    
    return {"is_stuck": is_stuck}
```

#### 1.3 在物理更新中调用检测

在 `pet_controller.gd` 的 `_physics_process` 中：

```gdscript
func _physics_process(delta: float) -> void:
    # ... 现有代码 ...
    
    # 检测卡住状态
    if control_mode == PetData.ControlMode.AI:
        var stuck_info = physics_module.check_stuck(self, delta)
        if stuck_info.get("is_stuck", false):
            # 上报卡住状态给服务端
            messaging_module.send_interaction("stuck", stuck_info, global_position)
            _log("[System] Stuck detected, reported to server")
```

### 第二步：客户端 - 消息上报

**文件**: `GAME/godot-pet/scripts/pet_messaging.gd`

确保 `send_interaction` 函数可以发送 `stuck` 事件：

```gdscript
func send_interaction(action: String, data: Dictionary, position: Vector3) -> void:
    var message = {
        "type": "interaction",
        "action": action,
        "data": data,
        "position": [position.x, position.y, position.z]
    }
    
    if ws_client:
        ws_client.send_message("interaction", message)
```

### 第三步：服务端 - 接收卡住事件

**文件**: `AVATAR/q_llm_pet/services/bt/BTServer.ts`

在 `handleMessage` 方法中添加处理：

```typescript
private handleMessage(ws: WebSocket, message: any) {
    const client = this.clients.get(ws);
    if (!client) return;

    const { type, data } = message;

    switch (type) {
        // ... 现有case ...
        
        case 'interaction':
            if (data.action === 'stuck') {
                this.handleStuckEvent(client, data);
            }
            break;
    }
}

private handleStuckEvent(client: ConnectedClient, data: any) {
    const blackboard = client.blackboard;
    
    // 记录卡住状态到黑板
    blackboard.set('isStuck', true);
    blackboard.set('stuckPosition', data.data.position);
    blackboard.set('stuckNormal', data.data.normal);
    blackboard.set('stuckTarget', data.data.target);
    blackboard.set('stuckTimestamp', Date.now());
    
    logWithTimestamp('warn', `[BTServer] Character stuck at ${data.data.position}`);
    
    // 触发行为树重新评估（如果需要）
    // 行为树可以通过 BlackboardGuard 检测 isStuck 状态
}
```

### 第四步：服务端 - 创建绕过行为树节点

**文件**: `AVATAR/q_llm_pet/services/bt/actions/ObstacleAvoidanceNode.ts` (新建)

```typescript
import { Action, Tick, SUCCESS, FAILURE, RUNNING } from 'behaviortree';
import EQSQueryNode from './EQSQueryNode';

interface ObstacleAvoidanceOptions {
    jumpOver?: boolean;  // 是否使用跳跃绕过
    useEQS?: boolean;    // 是否使用EQS查询绕过路径
    maxAttempts?: number; // 最大尝试次数
}

export default class ObstacleAvoidanceNode extends Action {
    private attempts: number = 0;
    
    constructor(options: ObstacleAvoidanceOptions = {}) {
        super({
            properties: {
                jumpOver: options.jumpOver ?? true,
                useEQS: options.useEQS ?? true,
                maxAttempts: options.maxAttempts ?? 3
            }
        });
    }

    tick(tick: Tick): number {
        const blackboard = tick.blackboard;
        const { jumpOver, useEQS, maxAttempts } = this.properties;
        
        // 检查是否卡住
        const isStuck = blackboard.get('isStuck');
        if (!isStuck) {
            this.attempts = 0;
            return FAILURE;  // 没有卡住，不需要绕过
        }
        
        // 检查尝试次数
        if (this.attempts >= maxAttempts) {
            console.log('[ObstacleAvoidance] Max attempts reached, giving up');
            blackboard.set('isStuck', false);  // 清除卡住状态
            this.attempts = 0;
            return FAILURE;
        }
        
        const stuckPosition = blackboard.get('stuckPosition') || [0, 0, 0];
        const stuckNormal = blackboard.get('stuckNormal') || [0, 0, 0];
        const stuckTarget = blackboard.get('stuckTarget') || [0, 0, 0];
        const currentPos = blackboard.get('penguinPosition') || [0, 0, 0];
        
        this.attempts++;
        console.log(`[ObstacleAvoidance] Attempt ${this.attempts}/${maxAttempts} to avoid obstacle`);
        
        if (useEQS) {
            // 方案A：使用EQS查询找到绕过路径
            return this.queryBypassPath(tick, currentPos, stuckTarget, stuckNormal);
        } else if (jumpOver) {
            // 方案B：直接跳跃绕过
            return this.jumpOverObstacle(tick, stuckNormal, stuckTarget);
        }
        
        return FAILURE;
    }
    
    private queryBypassPath(tick: Tick, startPos: number[], targetPos: number[], normal: number[]): number {
        const blackboard = tick.blackboard;
        
        // 计算绕过方向（垂直于障碍物法线）
        const normalVec = [normal[0], normal[1], normal[2]];
        const toTarget = [
            targetPos[0] - startPos[0],
            targetPos[1] - startPos[1],
            targetPos[2] - startPos[2]
        ];
        
        // 计算绕过点（在障碍物侧面）
        const bypassDistance = 2.0;  // 绕过距离2米
        const sideDirection = this.calculateSideDirection(normalVec, toTarget);
        const bypassPoint = [
            startPos[0] + sideDirection[0] * bypassDistance,
            startPos[1],
            startPos[2] + sideDirection[2] * bypassDistance
        ];
        
        // 使用EQS查询找到可到达的点
        // 这里可以调用 EQSQueryNode 或直接发送EQS查询
        
        // 临时方案：直接设置绕过点
        blackboard.set('bt_output_position', bypassPoint);
        blackboard.set('bt_output_action', 'RUN');
        
        console.log(`[ObstacleAvoidance] Setting bypass position: ${bypassPoint}`);
        return RUNNING;
    }
    
    private jumpOverObstacle(tick: Tick, normal: number[], targetPos: number[]): number {
        const blackboard = tick.blackboard;
        
        // 触发战术跳跃（跳跃+前冲）
        // 服务端发送 jump 动作，客户端执行战术跳跃
        blackboard.set('bt_output_action', 'JUMP');
        blackboard.set('jump_with_push', true);  // 标记需要前冲
        
        // 设置跳跃后的目标位置
        blackboard.set('jump_target', targetPos);
        
        console.log('[ObstacleAvoidance] Triggering jump over obstacle');
        return RUNNING;
    }
    
    private calculateSideDirection(normal: number[], toTarget: number[]): number[] {
        // 计算垂直于法线的方向（用于绕过）
        // 简化实现：使用叉积
        const cross = [
            normal[1] * toTarget[2] - normal[2] * toTarget[1],
            normal[2] * toTarget[0] - normal[0] * toTarget[2],
            normal[0] * toTarget[1] - normal[1] * toTarget[0]
        ];
        
        // 归一化
        const length = Math.sqrt(cross[0]**2 + cross[1]**2 + cross[2]**2);
        if (length > 0.001) {
            return [cross[0]/length, cross[1]/length, cross[2]/length];
        }
        
        // 如果叉积为零，使用默认方向
        return [1, 0, 0];
    }
    
    close(tick: Tick): void {
        // 清理状态
        this.attempts = 0;
    }
}
```

### 第五步：服务端 - 集成到行为树

**文件**: `AVATAR/q_llm_pet/services/bt/PenguinBT.ts` 或 `MainBT.ts`

在行为树中添加绕过逻辑：

```typescript
import ObstacleAvoidanceNode from './actions/ObstacleAvoidanceNode';

export function createPenguinBT(): BehaviorTree {
    const tree = new BehaviorTree();
    
    tree.root = new Parallel({
        title: 'Penguin Master Brain',
        policy: 'SuccessOnAll',
        children: [
            // ... 现有节点 ...
            
            new Priority({
                title: 'Decision Logic',
                children: [
                    // ... 现有优先级节点 ...
                    
                    // 新增：障碍物绕过（高优先级）
                    new BlackboardGuard({
                        title: 'Is Stuck?',
                        key: 'isStuck',
                        value: true,
                        scope: 'global',
                        child: new ObstacleAvoidanceNode({
                            title: 'Avoid Obstacle',
                            jumpOver: true,
                            useEQS: true,
                            maxAttempts: 3
                        })
                    }),
                    
                    // ... 其他节点 ...
                ]
            })
        ]
    });
    
    return tree;
}
```

### 第六步：客户端 - 处理战术跳跃指令

**文件**: `GAME/godot-pet/scripts/pet_controller.gd`

修改 `_on_action_state_applied` 函数：

```gdscript
func _on_action_state_applied(state: Dictionary) -> void:
    _log("[Server] Executing: %s" % state.name)
    animation_module.switch_anim(state.name)
    var a = state.name.to_lower()
    
    if a == "fly":
        is_flying = true
        velocity.y = 8.0
    elif a == "jump":
        # 检查是否需要战术跳跃（带前冲）
        var jump_with_push = state.get("with_push", false)
        var is_tactical = control_mode == PetData.ControlMode.AI and (is_server_moving or jump_with_push)
        physics_module.execute_jump(self, is_tactical)
        
        # 如果有跳跃目标，更新target_position
        if state.has("jump_target"):
            var jump_target = state.get("jump_target", [])
            if jump_target.size() >= 3:
                target_position = Vector3(jump_target[0], jump_target[1], jump_target[2])
                is_server_moving = true
```

**文件**: `AVATAR/q_llm_pet/services/bt/BTServer.ts`

在 `sendBTOutputs` 中处理跳跃动作：

```typescript
// 处理动作输出
const action = blackboard.get('bt_output_action');
if (action === 'JUMP') {
    const jumpWithPush = blackboard.get('jump_with_push') || false;
    const jumpTarget = blackboard.get('jump_target');
    
    this.sendMessage(ws, 'action', {
        name: 'jump',
        with_push: jumpWithPush,
        jump_target: jumpTarget
    });
    
    // 清除标记
    blackboard.set('jump_with_push', false);
    blackboard.set('jump_target', null);
}
```

## 实现优先级

### 阶段一：基础卡住检测（必须）
1. ✅ 客户端实现卡住检测
2. ✅ 客户端上报卡住事件
3. ✅ 服务端接收并记录到黑板

### 阶段二：简单绕过（推荐）
1. ✅ 服务端检测卡住状态
2. ✅ 触发直接跳跃绕过（不使用EQS）
3. ✅ 客户端执行战术跳跃

### 阶段三：智能绕过（可选）
1. ⬜ 使用EQS查询找到最佳绕过路径
2. ⬜ 结合LLM决策，让AI"思考"绕过策略
3. ⬜ 支持多种绕过方式（跳跃、绕行、爬升等）

## 测试方案

### 测试场景
1. **场景1**：角色在舞台边缘，目标在舞台上方
   - 预期：检测到卡住，执行跳跃+前冲，成功到达目标
   
2. **场景2**：角色被墙壁阻挡
   - 预期：检测到卡住，使用EQS查询找到绕行路径
   
3. **场景3**：角色在复杂障碍物环境中
   - 预期：多次尝试绕过，如果失败则放弃并报告

### 调试日志
- 客户端：`[Physics] Character is STUCK!`
- 服务端：`[BTServer] Character stuck at ...`
- 服务端：`[ObstacleAvoidance] Attempt X/Y to avoid obstacle`

## 注意事项

1. **性能考虑**：卡住检测不要过于频繁，建议0.5秒检查一次
2. **误判处理**：避免在正常移动时误判为卡住（如爬坡、慢速移动）
3. **状态同步**：确保客户端和服务端的卡住状态同步
4. **绕过失败**：如果多次尝试失败，应该放弃并报告，避免无限循环

## 扩展方向

1. **学习能力**：记录绕过成功的路径，下次遇到类似障碍物时优先使用
2. **动态调整**：根据障碍物高度动态调整跳跃力度
3. **多策略融合**：结合跳跃、绕行、爬升等多种策略
4. **LLM增强**：让LLM分析障碍物类型，选择最佳绕过策略

## 相关文件清单

### 需要修改的文件
- `GAME/godot-pet/scripts/pet_physics.gd` - 添加卡住检测
- `GAME/godot-pet/scripts/pet_controller.gd` - 调用检测并上报
- `GAME/godot-pet/scripts/pet_messaging.gd` - 确保可以发送stuck事件
- `AVATAR/q_llm_pet/services/bt/BTServer.ts` - 接收stuck事件
- `AVATAR/q_llm_pet/services/bt/PenguinBT.ts` - 集成绕过节点

### 需要新建的文件
- `AVATAR/q_llm_pet/services/bt/actions/ObstacleAvoidanceNode.ts` - 绕过行为树节点

## 总结

本方案通过**客户端检测 + 服务端决策**的方式，实现了智能障碍物绕过能力。核心思路是：
1. 客户端检测卡住状态并上报
2. 服务端收到后触发绕过逻辑（跳跃或EQS查询）
3. 客户端执行服务端的绕过指令

这种设计既保证了响应速度（客户端快速检测），又保证了决策质量（服务端统一决策，可利用EQS和LLM）。
