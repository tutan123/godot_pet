# 状态声明式通信架构改进方案

## 问题分析

### 原始问题
1. **FLY 动作被立即覆盖**：执行 FLY 后，下一个 tick（100ms）就被默认 IDLE 或 ReturnToOrigin 覆盖
2. **缺少动作锁定机制**：正在执行的动作序列没有保护，被低优先级节点中断
3. **通信模式不当**：当前是"指令覆盖式"，应该改为"状态声明式+优先级仲裁"

### 网络游戏最佳实践参考
- **状态同步（State Sync）**：服务端发送期望状态，客户端平滑过渡
- **优先级仲裁（Priority Arbitration）**：高优先级动作可以中断低优先级
- **动作队列（Action Queue）**：支持动作序列执行，防止覆盖

## 解决方案架构

### 1. 服务端改进（JS）

#### 动作锁定机制
```typescript
// ExecuteActionSequence.ts
- 增加 actionLock / actionLockToken / actionLockPriority
- LLM 指令优先级：50（中等）
- 执行期间锁定，防止被低优先级节点覆盖
- 动作完成时自动释放锁定
```

#### 状态声明式协议
```typescript
// BTServer.ts - sendBTOutputs()
actionState: {
  name: "FLY",
  duration: 5000,  // 毫秒
  priority: 50,    // 优先级（越高越优先）
  interruptible: true,  // 是否可被更高优先级中断
  timestamp: Date.now()
}
```

#### 优先级层次
- **100+**: 紧急事件（拖拽、碰撞、边界检查）- 由各自节点直接设置
- **50**: LLM 指令（ExecuteActionSequence）
- **30**: 普通动作（PlayAnimationAction，非 IDLE）
- **10**: 默认 IDLE（最低优先级，不覆盖任何动作）

### 2. 客户端改进（Godot）

#### 状态声明式管理
```gdscript
# pet_controller.gd
var current_action_state: Dictionary = {}  # 当前动作状态
var action_lock_time: float = 0.0  # 动作锁定到期时间

func _apply_action_state(action_state: Dictionary):
  # 1. 检查优先级和中断规则
  # 2. 决定是否中断当前动作
  # 3. 应用新动作状态
  # 4. 设置锁定时间
```

#### 优先级中断规则
1. **高优先级可以中断低优先级**：priority > current_priority
2. **可中断的动作可以被覆盖**：interruptible == true
3. **动作完成自动释放**：elapsed >= duration
4. **拖拽最高优先级**：直接中断所有动作

### 3. 行为树改进

#### RobotBT 优化
```typescript
// 默认 IDLE 增加锁定检查
new BlackboardGuard({
  title: 'No Action Lock?',
  key: (bb) => {
    const isLocked = bb.get('actionLock') || false;
    const hasPendingActions = (bb.get('pendingActions') || []).length > 0;
    return !isLocked && !hasPendingActions;
  },
  child: new PlayAnimationAction({ action: 'IDLE' })
})
```

#### ExecuteActionSequence 锁定保护
- 开始执行时：设置锁定（priority=50）
- 执行期间：保持锁定，防止被覆盖
- 动作完成：自动释放锁定

## 通信流程示例

### 场景：用户命令"飞起来"

```
1. 用户输入 -> IntentBT -> LLM 返回 FLY 动作
2. FunctionExecNode -> pendingActions = ["FLY"]
3. MainBT Tick (100ms):
   - ExecuteActionSequence 检测到 pendingActions
   - 设置 actionLock = true, priority = 50
   - 输出 bt_output_action = "FLY", duration = 5000ms
4. BTServer -> 发送 actionState 到客户端
5. Godot 客户端:
   - 接收 actionState
   - 检查优先级（当前无动作，直接应用）
   - 设置 proc_anim_active = "fly"
   - 锁定 5 秒
6. 下一个 Tick (200ms):
   - ExecuteActionSequence 继续 RUNNING
   - actionLock 仍然有效
   - RobotBT 的默认 IDLE 检查到锁定，FAILURE，不执行
7. 5 秒后：
   - ExecuteActionSequence 完成
   - 释放 actionLock
   - Godot 客户端清除 proc_anim_active
   - 默认 IDLE 可以执行
```

### 场景：飞行中被拖拽中断

```
1. FLY 正在执行（priority=50, duration=5000ms）
2. 用户拖拽 -> isDragging = true
3. MainBT Tick:
   - FollowPointerNode 检测到拖拽
   - 设置 bt_output_action = "JUMP", priority = 100
4. BTServer -> 发送高优先级动作
5. Godot 客户端:
   - 检查：priority 100 > 50，应该中断
   - 中断 FLY，应用 JUMP
   - 执行拖拽跟随逻辑
```

## 关键改进点

### 1. 泛化性
- 支持任意动作类型（骨骼动画 + 程序化动画）
- 优先级系统可扩展
- 状态声明式协议易于扩展

### 2. 适配性
- 向后兼容：仍然支持旧的 `action` 字段
- 新旧协议可以共存
- 客户端自动降级处理

### 3. Scaling
- 支持动作队列（未来可扩展）
- 支持多客户端并发（每个客户端独立锁定）
- 状态同步频率可调（当前 100ms，可根据需求调整）

## 与网络游戏的对比

| 特性 | 网络游戏（MMO） | 我们的实现 |
|------|----------------|-----------|
| 状态同步 | 位置、速度、状态 | 动作、表情、位置 |
| 优先级仲裁 | 技能优先级 | 动作优先级 |
| 动作队列 | 技能队列 | 动作序列队列 |
| 插值平滑 | 位置插值 | 动画过渡 |
| 客户端预测 | 本地预测 | 程序化动画叠加 |

## 测试验证

1. ✅ FLY 动作可以执行 5 秒不被覆盖
2. ✅ 默认 IDLE 不会覆盖正在执行的 FLY
3. ✅ 拖拽可以中断 FLY（高优先级）
4. ✅ 动作完成后自动释放锁定
5. ✅ 支持向后兼容（旧协议仍然工作）

## 未来扩展

1. **动作队列**：支持多个动作排队执行
2. **动作混合**：支持动作叠加（如走路+挥手）
3. **客户端预测**：更平滑的动画过渡
4. **状态压缩**：减少网络传输数据量
