# 状态声明式通信架构改进方案 (马尔可夫决策版)

## 架构升级：从"逻辑锁"到"马尔可夫决策转移"

### 核心设计理念

1. **马尔可夫性质 (Markov Property)**：行为树的每一帧决策仅依赖于黑板上当前的传感器数据（Sensor）。AI 不再需要记住"上一秒我发了什么指令"，而是每一帧都根据当前环境（用户是否在动、是否有 LLM 指令、是否撞墙）重新计算意图。
2. **输入输出彻底隔离 (Input/Output Separation)**：
   - **传感器 (Sensors)**：`isMovingLocally`, `isJumpPressed` 等反映客户端物理事实的变量。
   - **执行器 (Actuator)**：`bt_output_action` 反映 AI 主动干预的意图。
3. **AI 让路机制 (User Control Observer)**：通过行为树的优先级分支，AI 在观测到用户正在操作时，显式做出"放弃输出"的决策，从而消除了指令冲突。

### 架构演进对比

```mermaid
graph LR
    subgraph Old["旧架构（逻辑锁模式）"]
        O1[行为树执行]
        O2[检查锁]
        O3[获取锁]
        O4[发送指令]
        O5[释放锁]
        O1 --> O2
        O2 --> O3
        O3 --> O4
        O4 --> O5
    end
    
    subgraph New["新架构（马尔可夫决策）"]
        N1[行为树 Tick]
        N2[读取传感器]
        N3[马尔可夫决策]
        N4[声明意图]
        N5[状态变化检测]
        N1 --> N2
        N2 --> N3
        N3 --> N4
        N4 --> N5
    end
    
    style Old fill:#ffcdd2
    style New fill:#c8e6c9
```

**关键区别**：
- **旧架构**：需要维护锁定状态，容易产生死锁和冲突
- **新架构**：每帧独立决策，基于当前状态，无状态依赖

---

## 行为树决策优先级 (RobotBT.ts)

### 优先级层次

AI 每一帧按以下优先级进行马尔可夫决策：

```mermaid
graph TD
    Start[行为树 Tick 100ms]
    Priority[Priority 节点]
    
    subgraph P1["紧急干预层 (Priority 100+)"]
        Drag[拖拽交互<br/>isDragging]
        Collision[碰撞反应<br/>lastCollision]
    end
    
    subgraph P2["主动意图层 (Priority 50)"]
        LLM[LLM 指令序列<br/>ExecuteActionSequence]
    end
    
    subgraph P3["用户操作观察层 (Markov Yield)"]
        User[User Control Observer<br/>isMovingLocally<br/>isJumpPressed]
        Yield[让路：不输出]
    end
    
    subgraph P4["默认状态层 (Priority 10)"]
        Idle[IDLE<br/>PlayAnimationAction]
    end
    
    Start --> Priority
    Priority --> Drag
    Priority --> Collision
    Priority --> LLM
    Priority --> User
    Priority --> Idle
    
    Drag -->|输出动作| Action1[bt_output_action]
    Collision -->|输出 BOUNCE| Action2[bt_output_action]
    LLM -->|执行序列| Action3[bt_output_action]
    User -->|让路| Yield
    Yield -->|不输出| None[bt_output_action = null]
    Idle -->|输出 IDLE| Action4[bt_output_action]
    
    style P1 fill:#ffcdd2
    style P2 fill:#fff9c4
    style P3 fill:#c8e6c9
    style P4 fill:#e1bee7
```

### 优先级说明

1. **紧急干预层 (Priority 100+)**：拖拽、碰撞。AI 观察到传感器信号，立即接管肢体输出 `bt_output_action`。
2. **主动意图层 (Priority 50)**：执行来自 LLM 的动作序列。
3. **用户操作观察层 (Markov Yield)**：
   - **逻辑**：检查 `isMovingLocally` || `isJumpPressed`。
   - **决策**：如果为真，执行 `node_yield_control` 节点。该节点返回 SUCCESS 但不写入任何输出。
   - **结果**：优先级链条在这里终止，防止流向底层的 IDLE 节点。
4. **默认状态层 (Priority 10)**：只有上述都没有发生时，AI 才输出 `IDLE`。

---

## 通信协议改进：声明式同步

### 1. 持续声明，按需发送

行为树每一帧都在黑板上声明它当前的期望意图（或者声明让路）。`BTServer.ts` 负责检测这个"意图"是否发生了变化：

#### 状态变化检测

```mermaid
graph TD
    Tick[行为树 Tick]
    Declare[声明意图<br/>blackboard.set bt_output_action]
    Check[状态变化检测<br/>sendBTOutputs]
    Compare{状态是否变化?}
    Send[发送 bt_output<br/>actionState]
    Skip[跳过发送<br/>不发送消息]
    
    Tick --> Declare
    Declare --> Check
    Check --> Compare
    
    Compare -->|动作名改变<br/>IDLE -> JUMP| Send
    Compare -->|优先级提升<br/>30 -> 100| Send
    Compare -->|持续时间改变| Send
    Compare -->|无变化| Skip
    
    style Send fill:#c8e6c9
    style Skip fill:#ffcdd2
```

**状态变化条件**：
- **动作名改变** (IDLE -> JUMP)
- **优先级提升** (30 -> 100)
- **参数变化** (Duration 改变)

只有发生以上变化时，服务器才会向客户端发送一个 `actionState` 包。

#### 代码实现

```typescript
// BTServer.ts - sendBTOutputs()
let action = blackboard.get('bt_output_action');

if (action) {
  const actionState = {
    name: action,
    duration: actionDuration || 3000,
    priority: actionPriority || 50,
    interruptible: actionInterruptible !== false,
    timestamp: Date.now()
  };
  
  // 声明式通信：只在状态变化时发送
  const stateChanged = action !== client.lastSentAction || 
                     actionPriority > (client.lastActionPriority || 0) ||
                     actionDuration !== (client.lastSentActionDuration || 0);
  
  if (stateChanged) {
    outputs.actionState = actionState;
    client.lastSentAction = action;
    client.lastActionPriority = actionPriority;
  }
}
```

### 2. 客户端表现层 (BlendTree)

客户端不再是简单的"播放器"，而是根据服务端下发的 `actionState` 参数进行平滑混合。

#### BlendTree 结构

```mermaid
graph TD
    subgraph BlendTree["AnimationTree (BlendTree)"]
        Root[Root Node]
        Locomotion[Locomotion BlendTree<br/>Idle/Walk/Run]
        JumpOverlay[Jump Blend<br/>Overlay Layer]
        BaseAnim[Base Animation]
        JumpAnim[Jump Animation]
        
        Root --> Locomotion
        Locomotion --> BaseAnim
        Root --> JumpOverlay
        JumpOverlay --> JumpAnim
    end
    
    ActionState[actionState<br/>name: DANCE<br/>priority: 50<br/>duration: 3000]
    Params[混合参数<br/>blend_position<br/>jump_blend]
    
    ActionState -->|_apply_action_state| Params
    Params --> BlendTree
    
    style BlendTree fill:#e1f5ff
    style ActionState fill:#fff9c4
    style Params fill:#fff9c4
```

**混合层次**：
- **Locomotion 层**：处理基础的 Idle/Walk/Run。
- **Overlay 层**：通过 `jump_blend` 等节点将特殊动作叠加在基础层之上。

---

## 马尔可夫决策流程示例

### 场景 1：用户操控 WASD 过程中，AI 观察

```mermaid
sequenceDiagram
    participant User as 用户
    participant Client as Godot客户端
    participant Blend as BlendTree
    participant WS as WebSocket
    participant Server as BTServer
    participant BB as Blackboard
    participant BT as BehaviorTree
    
    Note over User,BT: T=0ms: 用户按下 W 键
    
    rect rgb(200, 255, 200)
        Note over User,Blend: 1. 本地立即响应（零延迟）
        User->>Client: 按下 W 键
        Client->>Client: _physics_process()<br/>检测输入
        Client->>Blend: 设置 blend_position = 0.5 (Walk)
        Blend->>User: 角色立即开始行走
    end
    
    rect rgb(255, 249, 200)
        Note over Client,BB: 2. 状态同步（1秒）
        Client->>WS: state_sync {is_moving_locally: true}
        WS->>Server: 接收消息
        Server->>BB: set('isMovingLocally', true)
    end
    
    rect rgb(255, 204, 188)
        Note over BB,BT: 3. 马尔可夫决策（T=100ms）
        BB->>BT: tick()
        BT->>BT: 读取黑板：isMovingLocally = true
        BT->>BT: 决策流：跳过 1, 2 分支<br/>命中 User Control Observer
        BT->>BT: 返回 SUCCESS<br/>bt_output_action 保持为空
        BT->>BB: 不写入 bt_output_action
    end
    
    rect rgb(200, 255, 200)
        Note over Server,Client: 4. 状态同步检查（T=100ms）
        Server->>Server: sendBTOutputs()<br/>检测 bt_output_action = null
        Server->>Server: 状态未变化，不发送消息
        Note over Client: 完全本地控制，无网络冲突
    end
```

**详细步骤**：

1. **T=0ms (Godot)**：检测到 W 按下，本地瞬间切换 Walk 混合参数，上报 `is_moving_locally: true`。
2. **T=100ms (Server BT)**：
   - 读取黑板：`isMovingLocally = true`。
   - 决策流：跳过 1, 2 分支 -> 命中 3 (User Control Observer)。
   - 决策结果：返回 SUCCESS，且 `bt_output_action` 保持为空。
3. **T=100ms (Server Sync)**：检测到 `bt_output_action` 没有任何新意图，**不发送任何消息**。
4. **结论**：完全本地控制，没有任何网络冲突。

### 场景 2：用户移动中，LLM 指令来了

```mermaid
sequenceDiagram
    participant User as 用户
    participant Client as Godot客户端
    participant Server as BTServer
    participant BT as BehaviorTree
    participant LLM as LLM API
    
    Note over User,LLM: 用户正在移动，输入 "跳个舞"
    
    User->>Client: 按下 W 键（移动中）
    Client->>Server: state_sync {is_moving_locally: true}
    Server->>BT: tick()
    BT->>BT: User Control Observer 让路
    
    User->>Server: 输入 "跳个舞"
    Server->>LLM: LLM 调用
    LLM-->>Server: 返回 Function Call<br/>animate_avatar(["DANCE"])
    Server->>BT: pendingActions = ["DANCE"]
    BT->>BT: ExecuteActionSequence<br/>优先级 50 > User Observer
    Note over BT: 优先级高于 User Observer，执行动作
    Server->>Client: bt_output {actionState: {name: "DANCE", priority: 50}}
    Client->>Client: _apply_action_state()<br/>优先级检查通过
    Client->>User: 角色开始跳舞（叠加在移动上）
```

### 场景 3：碰撞反应

```mermaid
sequenceDiagram
    participant Client as Godot客户端
    participant Server as BTServer
    participant BT as BehaviorTree
    participant BB as Blackboard
    
    Note over Client,BB: 角色碰撞到障碍物
    
    Client->>Client: _physics_process()<br/>检测到碰撞
    Client->>Server: interaction {action: "collision",<br/>collider_name: "Platform1",<br/>position: [...], normal: [...]}
    Server->>BB: set('lastCollision', {...})
    BB->>BT: tick()
    BT->>BT: BlackboardGuard<br/>检测到 lastCollision（800ms内）
    BT->>BB: PushPendingAction<br/>{actions: ["BOUNCE"], emotion: "SURPRISED"}
    BT->>BT: ExecuteActionSequence<br/>执行 BOUNCE（优先级 50）
    Server->>Client: bt_output {actionState: {name: "BOUNCE", priority: 50}}
    Client->>Client: 播放弹跳动画
```

---

## 优势总结

### 核心优势

1. **零冲突**：AI 主动感知并避让用户操作。
2. **无延迟**：本地控制无需等待服务端确认。
3. **逻辑一致性**：所有行为都通过一套优先级规则进行裁决，符合马尔可夫决策模型。

### 架构对比

| 维度 | 旧架构（逻辑锁） | 新架构（马尔可夫决策） |
|:-----|:----------------|:---------------------|
| **状态依赖** | 需要维护锁定状态 | 每帧独立决策，无状态依赖 |
| **冲突处理** | 锁机制，可能死锁 | AI 主动让路，优先级仲裁 |
| **延迟** | 网络往返 + 锁检查 | 零延迟（本地控制） |
| **复杂度** | 需要管理锁的生命周期 | 简单，每帧重新评估 |
| **可扩展性** | 锁机制难以扩展 | 易于添加新决策分支 |

### 性能对比

```mermaid
graph LR
    subgraph Old["旧架构性能"]
        O1[网络往返: 100ms]
        O2[锁检查: 10ms]
        O3[总延迟: 110ms]
        O1 --> O2
        O2 --> O3
    end
    
    subgraph New["新架构性能"]
        N1[本地响应: 0ms]
        N2[状态同步: 异步]
        N3[总延迟: 0ms]
        N1 --> N2
        N2 --> N3
    end
    
    style Old fill:#ffcdd2
    style New fill:#c8e6c9
```

### 关键设计模式

```mermaid
mindmap
  root((马尔可夫决策架构))
    输入输出隔离
      传感器数据 Sensors
      执行器数据 Actuators
      完全解耦
    AI 让路机制
      User Control Observer
      优先级仲裁
      主动避让
    状态声明式
      持续声明
      按需发送
      状态变化检测
    零延迟响应
      本地物理闭环
      立即动画切换
      流畅用户体验
```
