# 状态声明式通信架构改进方案

## 问题分析

### 原始问题
1. **FLY 动作被立即覆盖**：执行 FLY 后，下一个 tick（100ms）就被默认 IDLE 或 ReturnToOrigin 覆盖
2. **缺少动作锁定机制**：正在执行的动作序列没有保护，被低优先级节点中断
3. **通信模式不当**：当前是"指令覆盖式"，应该改为"状态声明式+优先级仲裁"

### 网络游戏最佳实践参考
- **状态同步（State Sync）**：服务端发送期望状态，客户端平滑过渡
- **优先级仲裁（Priority Arbitration）**：高优先级动作可以中断低优先级
- **动作队列（Action Queue）**：支持动作序列执行，防止覆盖

## 解决方案架构

### 1. 服务端改进（JS）

#### 动作锁定机制
```typescript
// ExecuteActionSequence.ts
- 增加 actionLock / actionLockToken / actionLockPriority
- LLM 指令优先级：50（中等）
- 执行期间锁定，防止被低优先级节点覆盖
- 动作完成时自动释放锁定
```

#### 状态声明式协议
```typescript
// BTServer.ts - sendBTOutputs()
actionState: {
  name: "FLY",
  duration: 5000,  // 毫秒
  priority: 50,    // 优先级（越高越优先）
  interruptible: true,  // 是否可被更高优先级中断
  timestamp: Date.now()
}
```

#### 优先级层次
- **100+**: 紧急事件（拖拽、碰撞、边界检查）- 由各自节点直接设置
- **50**: LLM 指令（ExecuteActionSequence）
- **30**: 普通动作（PlayAnimationAction，非 IDLE）
- **10**: 默认 IDLE（最低优先级，不覆盖任何动作）

### 2. 客户端改进（Godot）

#### 状态声明式管理
```gdscript
# pet_controller.gd
var current_action_state: Dictionary = {}  # 当前动作状态
var action_lock_time: float = 0.0  # 动作锁定到期时间

func _apply_action_state(action_state: Dictionary):
  # 1. 检查优先级和中断规则
  # 2. 决定是否中断当前动作
  # 3. 应用新动作状态
  # 4. 设置锁定时间
```

#### 优先级中断规则
1. **高优先级可以中断低优先级**：priority > current_priority
2. **可中断的动作可以被覆盖**：interruptible == true
3. **动作完成自动释放**：elapsed >= duration
4. **拖拽最高优先级**：直接中断所有动作

### 3. 行为树改进

#### RobotBT 优化
```typescript
// 默认 IDLE 增加锁定检查
new BlackboardGuard({
  title: 'No Action Lock?',
  key: (bb) => {
    const isLocked = bb.get('actionLock') || false;
    const hasPendingActions = (bb.get('pendingActions') || []).length > 0;
    return !isLocked && !hasPendingActions;
  },
  child: new PlayAnimationAction({ action: 'IDLE' })
})
```

#### ExecuteActionSequence 锁定保护
- 开始执行时：设置锁定（priority=50）
- 执行期间：保持锁定，防止被覆盖
- 动作完成：自动释放锁定

## 声明式通信核心原理

### 核心设计理念

**声明式通信（Declarative Communication）** 的关键是：
1. **行为树持续声明期望状态**：每个 tick 都在 blackboard 中声明期望的动作状态
2. **只在状态变化时发送**：`sendBTOutputs` 检测变化（动作名、优先级、duration），只在变化时发送
3. **客户端维护状态**：客户端收到状态后，自己维护该状态直到收到新状态
4. **不清除 blackboard**：发送后不清除，让行为树持续声明，直到状态改变

### shouldSend 逻辑详解

```typescript
// BTServer.ts - sendBTOutputs()
const stateChanged = 
    action !== client.lastSentAction ||           // 1. 动作名称变化
    actionPriority > client.lastActionPriority || // 2. 优先级提升（更高优先级覆盖）
    actionDuration !== client.lastSentActionDuration; // 3. 持续时间变化

if (stateChanged) {
    // 发送新状态
    outputs.actionState = actionState;
    // 更新记录的状态
    client.lastSentAction = action;
    client.lastActionPriority = actionPriority;
    client.lastSentActionDuration = actionDuration;
}

// 关键：不清除 blackboard！
// blackboard 中的状态由行为树持续声明，直到行为树改变声明
```

### Tick 执行流程详解

每个 tick（100ms）的执行顺序：

```
Tick N (100ms):
├─ 1. 行为树执行 (MainBT.tick)
│   ├─ ExecuteActionSequence: 设置 bt_output_action = "FLY"
│   ├─ PlayAnimationAction (IDLE): 尝试设置 bt_output_action = "IDLE"
│   └─ 但由于 actionLock，IDLE 节点返回 FAILURE，不设置
│
├─ 2. sendBTOutputs 检测变化
│   ├─ 读取 blackboard.get('bt_output_action') = "FLY"
│   ├─ 检查：action !== lastSentAction? YES → stateChanged = true
│   ├─ 发送 actionState = {name: "FLY", priority: 50, duration: 5000}
│   └─ 更新 lastSentAction = "FLY", lastActionPriority = 50
│
└─ 3. 客户端接收并应用
    ├─ 收到 actionState
    ├─ _apply_action_state() 检查优先级
    ├─ 设置 proc_anim_active = "fly"
    └─ 设置 action_lock_time = now + 5.0

Tick N+1 (200ms):
├─ 1. 行为树执行
│   ├─ ExecuteActionSequence: 继续设置 bt_output_action = "FLY"（持续声明）
│   └─ PlayAnimationAction (IDLE): 仍然被锁定，FAILURE
│
├─ 2. sendBTOutputs 检测变化
│   ├─ 读取 blackboard.get('bt_output_action') = "FLY"
│   ├─ 检查：action === lastSentAction? YES (都是 "FLY")
│   ├─ 检查：actionPriority === lastActionPriority? YES (都是 50)
│   ├─ 检查：actionDuration === lastSentActionDuration? YES (都是 5000)
│   ├─ stateChanged = false → 不发送！
│   └─ 关键：不清除 blackboard，让行为树继续声明
│
└─ 3. 客户端：继续执行 FLY（维护状态直到收到新状态）

Tick N+50 (5100ms, 5秒后):
├─ 1. 行为树执行
│   ├─ ExecuteActionSequence: 动作完成
│   ├─ 清除 bt_output_action = null（行为树不再声明 FLY）
│   └─ 释放 actionLock
│
├─ 2. sendBTOutputs 检测变化
│   ├─ 读取 blackboard.get('bt_output_action') = null
│   └─ 没有动作，不发送
│
└─ 3. 下一个 Tick (5200ms):
    ├─ PlayAnimationAction (IDLE): 现在可以执行了（无锁定）
    ├─ 设置 bt_output_action = "IDLE", priority = 10
    ├─ sendBTOutputs 检测：IDLE !== FLY → stateChanged = true
    ├─ 发送 actionState = {name: "IDLE", priority: 10, duration: 3000}
    └─ 客户端：切换到 IDLE
```

## 通信流程示例

### 场景 1：用户命令"飞起来"（完整流程）

**时间线（每个 tick = 100ms）：**

```
T=0ms: 用户输入 "飞起来"
  → IntentBT 触发 LLM 调用
  → LLM 返回: {actions: ["FLY"], emotion: "EXCITED"}

T=100ms: MainBT Tick #1
  ├─ FunctionExecNode: 设置 pendingActions = ["FLY"]
  ├─ ExecuteActionSequence:
  │   ├─ 检测到 pendingActions[0] = "FLY"
  │   ├─ 设置 actionLock = true, priority = 50
  │   └─ 设置 bt_output_action = "FLY", duration = 5000ms
  └─ sendBTOutputs:
      ├─ 读取 bt_output_action = "FLY"
      ├─ 检查：FLY !== null (首次) → 发送！
      └─ WebSocket: {type: "bt_output", actionState: {name: "FLY", priority: 50, duration: 5000}}
  
  Godot 客户端:
  ├─ 接收 actionState
  ├─ _apply_action_state(): 当前无动作，直接应用
  ├─ 设置 proc_anim_active = "fly"
  └─ action_lock_time = now + 5.0

T=200ms: MainBT Tick #2
  ├─ ExecuteActionSequence:
  │   ├─ 仍在执行 FLY（elapsed = 100ms < 5000ms）
  │   └─ 继续设置 bt_output_action = "FLY"（持续声明）
  └─ sendBTOutputs:
      ├─ 读取 bt_output_action = "FLY"
      ├─ 检查：FLY === "FLY" (相同) → 不发送！
      └─ 不清除 blackboard（让行为树继续声明）

T=300ms ~ T=5000ms: 持续 Tick
  └─ 每个 tick 都重复 Tick #2 的逻辑
     - ExecuteActionSequence 持续声明 "FLY"
     - sendBTOutputs 检测到相同状态，不发送
     - 客户端继续执行 FLY 动画

T=5100ms: MainBT Tick #51
  ├─ ExecuteActionSequence:
  │   ├─ elapsed = 5100ms >= 5000ms（动作完成）
  │   ├─ 移动到下一个动作：currentIdx = 1（但 actions.length = 1）
  │   ├─ 序列完成，清除 bt_output_action = null
  │   └─ 释放 actionLock = false
  └─ sendBTOutputs:
      └─ bt_output_action = null，不发送

T=5200ms: MainBT Tick #52
  ├─ PlayAnimationAction (IDLE):
  │   ├─ 检查 actionLock: false（已释放）
  │   └─ 设置 bt_output_action = "IDLE", priority = 10
  └─ sendBTOutputs:
      ├─ 读取 bt_output_action = "IDLE"
      ├─ 检查：IDLE !== "FLY" → 状态变化！
      └─ 发送: {actionState: {name: "IDLE", priority: 10, duration: 3000}}
  
  Godot 客户端:
  ├─ 接收 actionState: IDLE, priority = 10
  ├─ _apply_action_state():
  │   ├─ 当前动作: FLY (priority = 50)
  │   ├─ 检查：10 > 50? NO（IDLE 优先级更低）
  │   └─ 但 FLY 已完成（elapsed >= duration），应用 IDLE
  └─ 设置 proc_anim_active = ""（清除程序化动画）
```

### 场景 2：飞行中被拖拽中断（优先级中断）

```
T=1000ms: FLY 正在执行
  ├─ 客户端状态: proc_anim_active = "fly", action_lock_time = T+5000ms
  └─ 服务端: bt_output_action = "FLY", actionLock = true

T=1500ms: 用户开始拖拽
  ├─ Godot 客户端: isDragging = true
  └─ state_sync 发送: {is_dragging: true}

T=1600ms: MainBT Tick
  ├─ FollowPointerNode:
  │   ├─ 检测到 isDragging = true
  │   ├─ 设置 bt_output_action = "JUMP", priority = 100（高优先级）
  │   └─ 不设置 actionLock（拖拽是紧急事件，直接覆盖）
  └─ sendBTOutputs:
      ├─ 读取 bt_output_action = "JUMP", priority = 100
      ├─ 检查：JUMP !== "FLY" → 状态变化！
      ├─ 检查：100 > 50 → 优先级更高！
      └─ 发送: {actionState: {name: "JUMP", priority: 100, duration: 1500}}

  Godot 客户端:
  ├─ 接收 actionState: JUMP, priority = 100
  ├─ _apply_action_state():
  │   ├─ 当前动作: FLY (priority = 50)
  │   ├─ 检查：100 > 50? YES → 应该中断！
  │   └─ 中断 FLY，应用 JUMP
  ├─ 设置 proc_anim_active = ""（清除 fly）
  └─ 执行拖拽跟随逻辑（本地处理）

T=1700ms: MainBT Tick
  ├─ FollowPointerNode: 继续设置 bt_output_action = "JUMP"
  └─ sendBTOutputs:
      └─ JUMP === "JUMP" (相同) → 不发送（状态未变化）

T=2000ms: 用户停止拖拽
  ├─ Godot 客户端: isDragging = false
  └─ state_sync 发送: {is_dragging: false}

T=2100ms: MainBT Tick
  ├─ FollowPointerNode: 不再设置 JUMP
  ├─ ExecuteActionSequence: 之前的 FLY 已被中断，pendingActions 可能已清除
  └─ PlayAnimationAction (IDLE): 设置 bt_output_action = "IDLE"
  └─ sendBTOutputs:
      └─ IDLE !== "JUMP" → 状态变化，发送 IDLE
```

### 场景 3：动作序列执行（WAVE → FLIP）

```
T=0ms: 用户输入 "挥手然后翻跟头"
  → LLM 返回: {actions: ["WAVE", "FLIP"]}

T=100ms: MainBT Tick #1
  ├─ ExecuteActionSequence:
  │   ├─ pendingActions = ["WAVE", "FLIP"]
  │   ├─ currentIdx = 0, actions[0] = "WAVE"
  │   ├─ 设置 bt_output_action = "WAVE", duration = 2000ms
  │   └─ sequenceStartTime = now
  └─ sendBTOutputs: 发送 WAVE

T=2100ms: MainBT Tick #21 (WAVE 完成)
  ├─ ExecuteActionSequence:
  │   ├─ elapsed = 2100ms >= 2000ms（WAVE 完成）
  │   ├─ currentIdx = 1, actions[1] = "FLIP"
  │   ├─ 设置 bt_output_action = "FLIP", duration = 2000ms
  │   └─ sequenceStartTime = now（重新开始计时）
  └─ sendBTOutputs:
      ├─ 检查：FLIP !== "WAVE" → 状态变化！
      └─ 发送: {actionState: {name: "FLIP", priority: 50, duration: 2000}}

T=4100ms: MainBT Tick #41 (FLIP 完成)
  ├─ ExecuteActionSequence:
  │   ├─ currentIdx = 2 >= actions.length（序列完成）
  │   ├─ 清除 pendingActions = []
  │   ├─ 清除 bt_output_action = null
  │   └─ 释放 actionLock
  └─ sendBTOutputs: bt_output_action = null，不发送

T=4200ms: MainBT Tick #42
  └─ PlayAnimationAction (IDLE): 设置 bt_output_action = "IDLE"
  └─ sendBTOutputs: 发送 IDLE（状态从 FLIP 变为 IDLE）
```

## 关键设计决策

### 为什么不清除 blackboard？

```typescript
// ❌ 错误做法（之前）：每次都清除
blackboard.set('bt_output_action', null); // 这破坏了声明式通信

// ✅ 正确做法（现在）：行为树持续声明，sendBTOutputs 只在变化时发送
// blackboard 中的状态由行为树持续声明，直到行为树改变声明
// sendBTOutputs 只是检测变化并发送，不负责清除
```

**原因：**
1. **声明式本质**：行为树声明期望状态，而不是发送指令
2. **状态连续性**：如果清除，下一个 tick 行为树需要重新声明，可能导致状态丢失
3. **变化检测**：只有在 blackboard 中持续存在，才能准确检测状态是否变化

### 为什么只在变化时发送？

```typescript
// ❌ 错误做法：每个 tick 都发送（会产生大量重复消息）
if (action) {
    send(actionState); // 每个 tick 都发送，浪费带宽
}

// ✅ 正确做法：只在状态变化时发送
if (stateChanged) {
    send(actionState); // 只在真正需要时发送
}
```

**原因：**
1. **减少网络开销**：避免每个 tick（100ms）都发送相同状态
2. **符合声明式原则**：客户端维护状态，服务端只通知变化
3. **日志清晰**：不会看到大量重复的 IDLE 日志

## 关键改进点

### 1. 泛化性
- 支持任意动作类型（骨骼动画 + 程序化动画）
- 优先级系统可扩展
- 状态声明式协议易于扩展

### 2. 适配性
- 向后兼容：仍然支持旧的 `action` 字段
- 新旧协议可以共存
- 客户端自动降级处理

### 3. Scaling
- 支持动作队列（未来可扩展）
- 支持多客户端并发（每个客户端独立锁定）
- 状态同步频率可调（当前 100ms，可根据需求调整）

## 与网络游戏的对比

| 特性 | 网络游戏（MMO） | 我们的实现 |
|------|----------------|-----------|
| 状态同步 | 位置、速度、状态 | 动作、表情、位置 |
| 优先级仲裁 | 技能优先级 | 动作优先级 |
| 动作队列 | 技能队列 | 动作序列队列 |
| 插值平滑 | 位置插值 | 动画过渡 |
| 客户端预测 | 本地预测 | 程序化动画叠加 |

## 测试验证

1. ✅ FLY 动作可以执行 5 秒不被覆盖
2. ✅ 默认 IDLE 不会覆盖正在执行的 FLY
3. ✅ 拖拽可以中断 FLY（高优先级）
4. ✅ 动作完成后自动释放锁定
5. ✅ 支持向后兼容（旧协议仍然工作）

## 未来扩展

1. **动作队列**：支持多个动作排队执行
2. **动作混合**：支持动作叠加（如走路+挥手）
3. **客户端预测**：更平滑的动画过渡
4. **状态压缩**：减少网络传输数据量
