# 音频格式处理说明

## 概述

本文档说明 Godot 客户端音频录制模块与 `voice_engine` 服务端的音频格式兼容性处理。

## voice_engine 服务端能力

`voice_engine` 服务端具备以下自动处理能力：

1. **多声道支持**：可以自动将立体声转换为单声道（取左右声道平均值）
2. **采样率转换**：可以自动将 48000Hz 重采样到 16000Hz（模型要求）
3. **默认配置**：WebSocket 接口默认假设 Godot 客户端发送的是立体声（`channels=2`）

## 当前实现

### 音频格式配置

```gdscript
const SAMPLE_RATE: int = 48000
const CHANNELS: int = 1  # 单声道
const FORMAT: int = AudioStreamWAV.FORMAT_16_BITS
```

### 声道转换逻辑

在 `audio_recorder.gd` 的 `_convert_audio()` 函数中：

- **如果录制的是单声道**：直接返回原始数据，无需转换
- **如果录制的是立体声**：自动转换为单声道（只取左声道）

```gdscript
# 核心转换逻辑：从立体声中提取左声道
if stream.stereo:
    # 双声道结构是 [L, L, R, R]（每个采样 2 字节）
    # 只取前两个字节（左声道）
    mono_data[write_idx] = raw_data[read_idx]
    mono_data[write_idx+1] = raw_data[read_idx+1]
    read_idx += 4  # 跳过右声道的 2 个字节
```

## 改动是否必须？

### 结论：**不是必须的，但有一定好处**

### 原因分析

1. **服务端已支持**：`voice_engine` 的 `pcm_to_float32()` 函数可以自动处理立体声输入
2. **可选优化**：客户端转换可以带来以下好处：
   - ✅ **减少传输数据量**：单声道数据量是立体声的一半
   - ✅ **提前处理**：减少服务器端计算负担
   - ✅ **更直接**：如果只需要左声道，在客户端处理更简单

### 两种方案对比

| 方案 | 优点 | 缺点 |
|------|------|------|
| **客户端转换**（当前实现） | 减少传输数据量、降低服务器负载 | 需要额外代码维护 |
| **服务端处理**（不转换） | 代码更简单、取平均值可能质量更好 | 传输数据量翻倍 |

## 可选优化建议

如果希望获得更好的音频质量，可以考虑在客户端也取平均值而不是只取左声道：

```gdscript
# 当前实现：只取左声道
mono_data[write_idx] = raw_data[read_idx]
mono_data[write_idx+1] = raw_data[read_idx+1]

# 可选优化：取左右声道平均值（与服务端行为一致）
var left = (raw_data[read_idx] | (raw_data[read_idx+1] << 8)) as int16
var right = (raw_data[read_idx+2] | (raw_data[read_idx+3] << 8)) as int16
var avg = (left + right) / 2
mono_data[write_idx] = avg & 0xFF
mono_data[write_idx+1] = (avg >> 8) & 0xFF
```

## 总结

- ✅ 当前实现可以正常工作，并且优化了传输效率
- ✅ 如果代码工作正常，可以保留当前实现
- ✅ 如果想简化代码，也可以删除转换逻辑，让 `voice_engine` 服务端处理
- 💡 建议：如果对音频质量有更高要求，可以考虑实现平均值转换

## 相关文件

- `scripts/audio_recorder.gd` - 音频录制模块
- `voice_engine/server/utils/audio_utils.py` - 服务端音频处理工具
- `voice_engine/server/api/routes/websocket.py` - WebSocket 接口配置
