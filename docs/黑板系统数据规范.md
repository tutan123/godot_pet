# 黑板系统 (Blackboard) 数据规范 v2.0

## 概述

黑板系统是服务端行为树的"短期记忆"和"感官中心"，用于在行为树节点之间共享数据，以及服务端与客户端之间的状态同步。

**重要说明**：
- 黑板系统仅用于**需要服务端和客户端共享**的数据
- 纯客户端或纯服务端的本地数据不应放在黑板中
- 所有黑板数据都有明确的读写方和频率规范

---

## 一、机器人状态 (Robot State) - 全局作用域

### 1.1 内部状态（服务端计算）

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `energy` | Number (0-100) | **写**: UpdateInternalStatesAction<br>**读**: BehaviorTree节点 | 每2秒 | 能量值，低于20会触发睡觉逻辑<br>每个动作消耗5点能量 |
| `boredom` | Number (0-100) | **写**: UpdateInternalStatesAction<br>**读**: BehaviorTree节点 | 每2秒 | 无聊度，高无聊度会触发主动对话<br>每秒增长1点 |

### 1.2 物理状态（客户端同步）

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `penguinPosition` | Array [x,y,z] | **写**: BTServer (接收state_sync)<br>**读**: BehaviorTree节点 | 每秒1次 | 机器人在3D空间中的实时坐标<br>客户端通过`state_sync`消息上报 |
| `isOnFloor` | Boolean | **写**: BTServer (接收state_sync)<br>**读**: BehaviorTree节点 | 每秒1次 | 是否在地面上<br>客户端通过`state_sync`消息上报 |

### 1.3 环境感知（客户端上报）

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `lastCollision` | Object | **写**: BTServer (接收collision)<br>**读**: BehaviorTree节点<br>**清除**: MainBT/RobotBT | 碰撞时 | 包含`collider_name`, `position`, `normal`, `timestamp`<br>碰撞后800ms内有效，行为树使用后自动清除 |

---

## 二、交互状态 (Interaction) - 全局作用域

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `isDragging` | Boolean | **写**: BTServer (接收drag_start/end)<br>**读**: BehaviorTree节点 | 拖拽时 | 当前是否正在被鼠标拖拽<br>最高优先级，直接中断所有动作 |
| `isClicked` | Boolean | **写**: BTServer (接收click)<br>**读**: BehaviorTree节点<br>**清除**: 500ms后自动 | 点击时 | 当前是否被单击（瞬时状态）<br>500ms后自动清除 |
| `lastUserInput` | String | **写**: BTServer (接收user_input)<br>**读**: LLMCallNode<br>**清除**: FunctionExecNode | 用户输入时 | 用户最后输入的文本指令<br>LLM调用后清除 |
| `hasNewInput` | Boolean | **写**: BTServer (接收user_input时设为true)<br>**读**: IntentBT<br>**清除**: IntentBT执行完成后 | 用户输入时 | 是否有未处理的新文本指令<br>触发IntentBT执行 |

---

## 三、LLM相关 (LLM Context) - 全局/树级作用域

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `llmSettings` | Object | **写**: BTServer (初始化或handshake)<br>**读**: LLMCallNode | 初始化或handshake时 | LLM配置：`{provider, apiKey, baseUrl, modelName, system_instruction}`<br>支持企鹅和机器人两种指令 |
| `chatHistory` | Array\<Object\> | **写**: BTServer注入<br>**读**: LLMCallNode | 每次LLM调用时 | 聊天历史记录，格式同OpenAI消息格式<br>BTServer从外部注入（如前端） |
| `lastLLMResult` | Object | **写**: LLMCallNode<br>**读**: FunctionExecNode<br>**清除**: FunctionExecNode | LLM调用完成后 | LLM返回的完整结果<br>包含`text`, `toolCalls`, `toolResult`等 |
| `llm_response` | Object | **写**: LLMCallNode<br>**读**: FunctionExecNode | LLM调用完成后 | LLM响应的原始数据（树级作用域） |
| `llm_raw_tool_calls` | Array\<Object\> | **写**: LLMCallNode<br>**读**: FunctionExecNode | LLM调用完成后 | LLM原始工具调用数组（树级作用域） |

---

## 四、动作决策输出 (Action Decision Outputs) - 全局作用域

### 4.1 动作序列队列

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `pendingActions` | Array\<String\> | **写**: FunctionExecNode<br>**读**: ExecuteActionSequence | LLM调用完成后 | 待执行的动作序列队列<br>如`['DANCE', 'WAVE']` |
| `pendingEmotion` | String | **写**: FunctionExecNode<br>**读**: EmotionBT | LLM调用完成后 | 待应用的表情<br>如`'HAPPY'`, `'SURPRISED'` |

### 4.2 动作输出（状态声明式协议）

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `bt_output_action` | String | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | 每100ms (BT tick) | 当前Tick需要立即发送给客户端的动作名<br>如`'DANCE'`, `'WAVE'` |
| `bt_output_action_duration` | Number | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | 每100ms (BT tick) | 动作持续时间（毫秒）<br>默认3000ms |
| `bt_output_action_priority` | Number | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | 每100ms (BT tick) | 动作优先级<br>LLM指令=50, 普通动作=30, IDLE=10 |
| `bt_output_action_interruptible` | Boolean | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | 每100ms (BT tick) | 动作是否可被更高优先级中断<br>默认true |

### 4.3 动作锁定机制

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `actionLock` | Boolean | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: ExecuteActionSequence / PlayAnimationAction | 动作开始/结束时 | 是否被动作锁定<br>防止低优先级节点覆盖正在执行的动作 |
| `actionLockToken` | String | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: ExecuteActionSequence / PlayAnimationAction | 动作开始/结束时 | 锁定者的节点ID<br>用于标识谁拥有锁定 |
| `actionLockPriority` | Number | **写**: ExecuteActionSequence / PlayAnimationAction<br>**读**: ExecuteActionSequence / PlayAnimationAction | 动作开始/结束时 | 当前锁定的优先级<br>用于判断是否可以中断 |

### 4.4 动作序列执行状态（树级作用域）

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `currentSequenceIdx` | Number | **写**: ExecuteActionSequence<br>**读**: ExecuteActionSequence | 每100ms (BT tick) | 当前执行到动作序列的第几个<br>树级作用域，每个节点独立 |
| `sequenceStartTime` | Number | **写**: ExecuteActionSequence<br>**读**: ExecuteActionSequence | 每100ms (BT tick) | 当前动作开始执行的时间戳<br>树级作用域，每个节点独立 |

---

## 五、其他输出 (Other Outputs) - 全局作用域

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `bt_output_expression` | String | **写**: PlayExpressionAction<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | 每100ms (BT tick) | 当前需要应用的表情<br>如`'HAPPY'`, `'SURPRISED'`（当前Godot端暂不处理） |
| `bt_output_chat_msgs` | Array\<Object\> | **写**: FunctionExecNode<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | LLM调用完成后 | 待发送的回复消息数组<br>包含协议消息和UI消息 |
| `bt_output_position` | Array [x,y,z] | **写**: FollowPointerNode / MoveToTargetAction<br>**读**: BTServer.sendBTOutputs()<br>**清除**: 发送后立即清除 | 每100ms (BT tick) | 服务端要求的移动目标位置<br>通过`move_to`消息发送 |

---

## 六、行为树内部状态 (BT Internal State) - 树级/节点级作用域

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `nodeStatuses` | Object | **写**: BehaviorTree.tick()<br>**读**: BTVisualizer | 每100ms (BT tick) | 所有节点的执行状态<br>`{nodeId: status}` status=1(SUCCESS)/2(FAILURE)/3(RUNNING) |
| `nodeDurations` | Object | **写**: BehaviorTree.tick()<br>**读**: Profiling | 每100ms (BT tick) | 所有节点的执行时长<br>`{nodeId: duration_ms}` |
| `nodeCount` | Number | **写**: BehaviorTree.tick()<br>**读**: Profiling | 每100ms (BT tick) | 本次tick执行的节点总数 |
| `openNodes` | Array\<BaseNode\> | **写**: BehaviorTree.tick()<br>**读**: BehaviorTree | 每100ms (BT tick) | 当前正在执行的节点列表 |
| `isOpen` | Boolean | **写**: BaseNode.open()/close()<br>**读**: BaseNode | 每100ms (BT tick) | 节点是否正在执行<br>节点级作用域，每个节点独立 |
| `startTime` | Number | **写**: PlayAnimationAction.open()<br>**读**: PlayAnimationAction | 动作开始时 | 动作开始执行的时间戳<br>节点级作用域，每个节点独立 |
| `energyConsumed` | Boolean | **写**: PlayAnimationAction<br>**读**: PlayAnimationAction | 动作开始时 | 是否已扣除能量<br>节点级作用域，每个节点独立 |

---

## 七、特殊用途数据

| 键名 | 类型 | 读写方 | 更新频率 | 说明 |
|:-----|:-----|:------|:---------|:-----|
| `pointerPosition` | Object {x,y,z} | **写**: FollowPointerNode (拖拽时)<br>**读**: FollowPointerNode | 拖拽时，每帧 | 鼠标在3D空间中的位置<br>用于拖拽交互 |

---

## 八、数据流向图

### 8.1 客户端 → 服务端

```
Godot客户端
    ↓ (WebSocket: state_sync, 每秒)
penguinPosition, isOnFloor
    ↓
BTServer.handleClientMessage()
    ↓
blackboard.set('penguinPosition', ...)
blackboard.set('isOnFloor', ...)
```

```
Godot客户端
    ↓ (WebSocket: user_input)
用户输入文本
    ↓
BTServer.handleClientMessage()
    ↓
blackboard.set('lastUserInput', text)
blackboard.set('hasNewInput', true)
```

```
Godot客户端
    ↓ (WebSocket: interaction: drag_start/end/click/collision)
交互事件
    ↓
BTServer.handleInteraction()
    ↓
blackboard.set('isDragging', ...)
blackboard.set('isClicked', ...)
blackboard.set('lastCollision', ...)
```

### 8.2 服务端 → 客户端

```
BehaviorTree节点
    ↓
blackboard.set('bt_output_action', 'DANCE')
blackboard.set('bt_output_action_duration', 3000)
blackboard.set('bt_output_action_priority', 50)
    ↓
BTServer.sendBTOutputs() (每100ms)
    ↓
构建 actionState: {name, duration, priority, interruptible, timestamp}
    ↓
WebSocket: bt_output {actionState: {...}}
    ↓
Godot客户端接收并应用
```

---

## 九、数据规范：如何增减黑板数据

### 9.1 新增黑板数据的步骤

#### 步骤1：确定是否需要放在黑板

**需要放在黑板的数据**：
- 需要服务端行为树节点之间共享的数据
- 需要客户端和服务端同步的数据
- 需要跨行为树共享的数据

**不需要放在黑板的数据**：
- 纯客户端本地数据（见"客户端本地数据"章节）
- 纯服务端本地数据（见"服务端本地数据"章节）
- 临时计算结果（不跨节点共享）

#### 步骤2：确定数据作用域

- **全局作用域**：`blackboard.set('key', value)` - 所有行为树和节点都可以访问
- **树级作用域**：`blackboard.set('key', value, treeId)` - 只在特定行为树内访问
- **节点级作用域**：`blackboard.set('key', value, treeId, nodeId)` - 只在特定节点内访问

#### 步骤3：确定读写方和频率

- **写入方**：明确哪个节点或模块负责写入
- **读取方**：明确哪些节点会读取
- **更新频率**：明确数据的更新频率（每帧、每tick、按需等）
- **清除时机**：明确数据何时清除（发送后、动作完成后等）

#### 步骤4：更新文档

在本文档中添加新数据项，包括：
- 键名、类型、读写方、更新频率、说明

### 9.2 删除黑板数据的步骤

1. **检查依赖**：搜索所有`blackboard.get('key')`和`blackboard.set('key')`的使用
2. **移除代码**：删除所有相关代码
3. **更新文档**：从本文档中删除对应条目

### 9.3 数据命名规范

- **状态数据**：使用名词，如`energy`, `boredom`, `isDragging`
- **输出数据**：使用`bt_output_`前缀，如`bt_output_action`, `bt_output_expression`
- **临时数据**：使用`pending`前缀，如`pendingActions`, `pendingEmotion`
- **锁定数据**：使用`actionLock`前缀，如`actionLock`, `actionLockToken`, `actionLockPriority`
- **节点级数据**：使用驼峰命名，如`startTime`, `energyConsumed`

---

## 十、客户端本地数据（不放在黑板）

以下数据只存在于客户端，不需要通过黑板同步：

| 数据项 | 说明 | 位置 |
|:------|:-----|:-----|
| `current_action_state` | 当前动作状态（客户端本地管理） | `pet_controller.gd` |
| `action_queue` | 动作队列（客户端本地，当前未使用） | `pet_controller.gd` |
| `action_lock_time` | 动作锁定到期时间（客户端本地） | `pet_controller.gd` |
| `proc_anim_active` | 当前程序化动画名称 | `pet_controller.gd` |
| `proc_time` | 程序化动画时间计数器 | `pet_controller.gd` |
| `last_anim_state` | 上一个动画状态 | `pet_controller.gd` |
| `target_position` | 移动目标位置（客户端本地） | `pet_controller.gd` |
| `is_server_moving` | 是否正在执行服务端移动（客户端本地） | `pet_controller.gd` |
| `velocity` | 物理速度（客户端本地） | `pet_controller.gd` |
| `animation_tree` | 动画树实例（客户端本地） | `pet_controller.gd` |

**设计原则**：
- 客户端本地数据用于临时状态管理和动画播放
- 只有需要影响服务端决策的数据才同步到黑板
- 服务端只关心"期望状态"，不关心客户端的具体实现细节

---

## 十一、服务端本地数据（不放在黑板）

以下数据只存在于服务端，不需要通过黑板：

| 数据项 | 说明 | 位置 |
|:------|:-----|:-----|
| `lastSentAction` | 上次发送的动作（防止重复发送） | `BTServer.ConnectedClient` |
| `lastActionPriority` | 上次发送动作的优先级 | `BTServer.ConnectedClient` |
| `lastActivity` | 客户端最后活动时间 | `BTServer.ConnectedClient` |
| `clientType` | 客户端类型（penguin/robot） | `BTServer.ConnectedClient` |

**设计原则**：
- 服务端本地数据用于连接管理和去重
- 只有需要影响行为树决策的数据才放在黑板
- 行为树不应该依赖连接层面的实现细节

---

## 十二、数据访问模式示例

### 12.1 读取全局数据

```typescript
// 读取能量值
const energy = blackboard.get('energy');

// 读取位置
const pos = blackboard.get('penguinPosition');
```

### 12.2 写入全局数据

```typescript
// 设置能量值
blackboard.set('energy', 85);

// 设置位置
blackboard.set('penguinPosition', [1, -1, 2]);
```

### 12.3 读取树级数据

```typescript
// 读取LLM结果（树级作用域）
const result = blackboard.get('lastLLMResult', treeId);
```

### 12.4 写入树级数据

```typescript
// 设置LLM结果（树级作用域）
blackboard.set('lastLLMResult', result, treeId);
```

### 12.5 读取节点级数据

```typescript
// 读取节点开始时间（节点级作用域）
const startTime = blackboard.get('startTime', treeId, nodeId);
```

### 12.6 写入节点级数据

```typescript
// 设置节点开始时间（节点级作用域）
blackboard.set('startTime', Date.now(), treeId, nodeId);
```

---

## 十三、常见问题

### Q1: 为什么有些数据不放在黑板？

**A**: 黑板只用于需要**跨节点或跨服务端-客户端共享**的数据。纯本地数据不需要放在黑板，避免不必要的网络同步和复杂度。

### Q2: 如何判断数据应该放在哪个作用域？

**A**: 
- **全局作用域**：需要在多个行为树之间共享，或者需要客户端同步
- **树级作用域**：只在特定行为树内使用（如IntentBT的LLM结果）
- **节点级作用域**：只在特定节点内使用（如节点的临时状态）

### Q3: 动作状态为什么既有服务端锁定，又有客户端优先级检查？

**A**: 双重保障：
1. 服务端锁定：防止行为树内部冲突
2. 客户端优先级检查：防止网络延迟导致的旧消息覆盖新消息

### Q4: `bt_output_*` 数据为什么发送后要立即清除？

**A**: 这些是"输出标记"，用于指示BTServer发送给客户端。发送后应立即清除，避免重复发送。但动作锁定状态（`actionLock`）会保留，直到动作完成。

---

## 附录：数据访问频率汇总

| 更新频率 | 数据项 |
|:---------|:------|
| 每帧（60fps） | 无（客户端本地处理） |
| 每100ms (BT tick) | `bt_output_*`, `actionLock*`, `nodeStatuses`, `nodeDurations`, `openNodes`, `isOpen` |
| 每秒 | `penguinPosition`, `isOnFloor` (客户端同步) |
| 每2秒 | `energy`, `boredom` (服务端计算) |
| 按需触发 | `lastUserInput`, `hasNewInput`, `isClicked`, `isDragging`, `lastCollision`, `pendingActions`, `llm_*` |
