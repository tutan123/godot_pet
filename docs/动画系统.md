# 动画系统文档

## 目录
1. [系统概述](#系统概述)
2. [核心概念](#核心概念)
3. [动画类型分类](#动画类型分类)
4. [AnimationTree 和 BlendTree](#animationtree-和-blendtree)
5. [AnimationNodeAnimation 详解](#animationnodeanimation-详解)
6. [直接播放动画机制](#直接播放动画机制)
7. [程序化骨骼动画](#程序化骨骼动画)
8. [使用示例](#使用示例)

---

## 系统概述

本项目的动画系统采用了**混合架构**，结合了 Godot 的 AnimationTree、BlendTree 和直接 AnimationPlayer 控制，实现了灵活且高效的动画管理。

### 系统架构图

```
动画请求 (switch_anim)
    │
    ├─→ 程序化动画? (wave, flip, spin等)
    │   └─→ 程序化动画系统 (代码生成)
    │
    ├─→ 基础移动动画? (stand, walk, run, jump)
    │   └─→ AnimationTree + BlendTree (平滑过渡)
    │
    └─→ 其他动画
        └─→ AnimationPlayer 直接播放 (无需预定义)
```

---

## 核心概念

### AnimationTree

**AnimationTree** 是 Godot 中用于管理复杂动画状态的高级节点。它提供了：

- **参数驱动**：通过参数（如 `blend_position`）控制动画混合
- **状态管理**：管理多个动画状态之间的转换
- **性能优化**：比直接使用 AnimationPlayer 更高效

在我们的系统中，AnimationTree 主要用于**基础移动动画**的平滑过渡。

### BlendTree

**BlendTree**（混合树）是 AnimationTree 中的一种节点类型，用于在多个动画之间进行平滑混合。

#### BlendSpace1D（一维混合空间）

我们使用 `AnimationNodeBlendSpace1D` 来实现站立、行走、跑步之间的平滑过渡：

```
位置 0.0  → stand (站立)
位置 0.5  → walk (行走)
位置 1.0  → run (跑步)
```

通过设置 `blend_position` 参数（0.0 到 1.0），可以在三个动画之间平滑过渡。

#### Blend2（二路混合）

我们使用 `AnimationNodeBlend2` 来混合基础移动动画和跳跃动画：

```
blend_amount = 0.0  → 基础移动 (locomotion)
blend_amount = 1.0  → 跳跃动画 (jump)
```

### AnimationNodeAnimation

**AnimationNodeAnimation** 是 BlendTree 中的一个节点类型，它代表一个**具体的动画资源**。

#### 什么是 AnimationNodeAnimation？

在场景文件（`.tscn`）中，每个 `AnimationNodeAnimation` 节点都对应一个动画：

```gdscript
[sub_resource type="AnimationNodeAnimation" id="AnimationNodeAnimation_idle"]
animation = &"stand"  # 引用 AnimationPlayer 中的 "stand" 动画
```

**作用**：
- 将 AnimationPlayer 中的动画包装成 BlendTree 可以使用的节点
- 在 BlendTree 中作为"动画源"使用
- 可以被 BlendSpace 或其他混合节点引用

**为什么需要它？**

在传统的 AnimationTree 工作流中，每个要在 BlendTree 中使用的动画都需要：
1. 在 AnimationPlayer 中定义动画
2. 在场景文件中创建 `AnimationNodeAnimation` 节点
3. 将其添加到 BlendTree 中

**问题**：如果有 100 个动画，就需要创建 100 个 `AnimationNodeAnimation` 节点，非常繁琐。

**解决方案**：我们的系统实现了**直接播放机制**，对于非基础动画，无需创建 `AnimationNodeAnimation`。

---

## 动画类型分类

### 1. 基础移动动画（使用 BlendTree）

这些动画通过 AnimationTree 的 BlendTree 进行管理，支持平滑过渡：

- **stand** (站立) - 位置 0.0
- **walk** (行走) - 位置 0.5
- **run** (跑步) - 位置 1.0
- **jump** (跳跃) - 通过 Blend2 混合

**特点**：
- 需要平滑过渡（如从站立到行走）
- 在场景文件中预定义了 `AnimationNodeAnimation`
- 通过 `blend_position` 参数控制

**代码位置**：`pet.tscn` 第 10-23 行

### 2. 程序化动画（骨骼动画）

这些动画通过代码实时生成，不依赖预定义的动画资源：

- **wave** (挥手)
- **flip** (后空翻)
- **spin** (旋转)
- **bounce** (弹跳)
- **fly** (飞行)
- **roll** (滚动)
- **shake** (抖动)
- **dance** (跳舞)

**实现方式**：
- 直接操作骨骼（Skeleton3D）
- 通过数学函数计算骨骼位置和旋转
- 在 `apply_procedural_fx()` 中每帧更新

**代码位置**：`pet_animation.gd` 第 187-296 行

### 3. 直接播放动画（无需预定义）

除了基础移动动画和程序化动画之外的所有动画，都可以直接通过 AnimationPlayer 播放。

**特点**：
- 无需在场景文件中创建 `AnimationNodeAnimation`
- 只需在 GLB 模型中添加动画即可
- 自动识别并播放

**支持的动画数量**：理论上无限制（如 100 个、1000 个）

---

## AnimationTree 和 BlendTree

### 当前 BlendTree 结构

```
AnimationNodeBlendTree_root
    │
    ├─→ AnimationNodeBlend2 (jump_blend)
    │   ├─→ 0: AnimationNodeBlendSpace1D (locomotion)
    │   │   ├─→ 位置 0.0: stand
    │   │   ├─→ 位置 0.5: walk
    │   │   └─→ 位置 1.0: run
    │   └─→ 1: AnimationNodeAnimation (jump)
    │
    └─→ output
```

### 参数控制

#### locomotion/blend_position

控制基础移动动画的混合：

```gdscript
# 站立
animation_tree.set("parameters/locomotion/blend_position", 0.0)

# 行走
animation_tree.set("parameters/locomotion/blend_position", 0.3)

# 跑步
animation_tree.set("parameters/locomotion/blend_position", 1.0)
```

#### jump_blend/blend_amount

控制跳跃动画的混合：

```gdscript
# 不跳跃
animation_tree.set("parameters/jump_blend/blend_amount", 0.0)

# 跳跃
animation_tree.set("parameters/jump_blend/blend_amount", 1.0)
```

**代码位置**：`pet_animation.gd` 第 60-82 行

---

## AnimationNodeAnimation 详解

### 定义方式

在场景文件（`.tscn`）中：

```gdscript
[sub_resource type="AnimationNodeAnimation" id="AnimationNodeAnimation_idle"]
animation = &"stand"
```

**说明**：
- `type="AnimationNodeAnimation"`：节点类型
- `id="AnimationNodeAnimation_idle"`：资源 ID（用于引用）
- `animation = &"stand"`：引用的动画名称（来自 AnimationPlayer）

### 在 BlendTree 中使用

```gdscript
[sub_resource type="AnimationNodeBlendSpace1D" id="AnimationNodeBlendSpace1D_locomotion"]
blend_point_0/node = SubResource("AnimationNodeAnimation_idle")  # 引用上面的节点
blend_point_0/pos = 0.0
```

### 为什么需要它？

在传统的 AnimationTree 工作流中：
1. 每个动画都需要一个 `AnimationNodeAnimation` 节点
2. 如果有 100 个动画，就需要 100 个节点
3. 每次添加新动画都要修改场景文件

**我们的解决方案**：对于非基础动画，直接通过 AnimationPlayer 播放，无需创建 `AnimationNodeAnimation`。

---

## 直接播放动画机制

### 实现原理

当调用 `switch_anim("new_animation")` 时：

1. **检查动画类型**
   ```gdscript
   # 程序化动画？
   if is_procedural_anim(normalized_name):
       # 使用程序化动画系统
   
   # 基础移动动画？
   elif normalized_name in ["idle", "stand", "walk", "run", "jump"]:
       # 使用 BlendTree
   
   # 其他动画？
   else:
       # 直接播放
       _play_animation_directly(normalized_name)
   ```

2. **直接播放流程**
   ```gdscript
   func _play_animation_directly(anim_name: String):
       # 1. 暂停 AnimationTree
       animation_tree.active = false
       
       # 2. 检查动画是否存在
       if anim_player.has_animation(anim_name):
           # 3. 直接播放
           anim_player.play(anim_name)
           
           # 4. 如果是非循环动画，等待完成后恢复
           if not anim.loop_mode == Animation.LOOP_LINEAR:
               _wait_for_animation_finish(anim_name)
   ```

**代码位置**：`pet_animation.gd` 第 383-430 行

### 优势

1. **无需预定义**：不需要在场景文件中创建 `AnimationNodeAnimation`
2. **自动识别**：只需在 GLB 模型中添加动画，系统自动识别
3. **无限扩展**：支持任意数量的动画（100 个、1000 个都可以）
4. **简单维护**：添加新动画只需更新 GLB 模型，无需修改代码

### 循环动画 vs 一次性动画

#### 循环动画

```gdscript
# 在 pet_controller.gd 中设置
var stand_anim = anim_player.get_animation("stand")
stand_anim.loop_mode = Animation.LOOP_LINEAR  # 循环播放
```

**特点**：
- 播放完成后自动重复
- 不会触发 `animation_finished` 信号
- 适用于：stand, walk, run 等持续动作

#### 一次性动画

```gdscript
# 默认情况下，动画是一次性的
anim_player.play("punch")  # 播放一次后停止
```

**特点**：
- 播放完成后停止
- 触发 `animation_finished` 信号
- 播放完成后自动恢复 AnimationTree 并回到 idle 状态
- 适用于：punch, kick, dance 等动作

**代码位置**：`pet_animation.gd` 第 411-430 行

---

## 程序化骨骼动画

### 什么是程序化动画？

程序化动画是通过**代码实时计算**生成的动画，而不是使用预定义的动画资源。

### 实现方式

#### 1. 骨骼操作

```gdscript
# 获取骨骼 ID
right_arm_bone_id = skeleton.find_bone("r-arm")

# 设置骨骼位置和旋转
skeleton.set_bone_pose_position(bone_id, position)
skeleton.set_bone_pose_rotation(bone_id, rotation)
```

#### 2. 数学函数生成动画

以挥手动画为例：

```gdscript
func _apply_arm_wave_animation(delta: float):
    # 使用正弦函数生成挥舞角度
    var wave_angle = sin(proc_time * 8.0) * 1.2
    
    # 计算旋转变换
    var rotation_transform = Transform3D()
    rotation_transform = rotation_transform.rotated(Vector3(1, 0, 0), wave_angle)
    
    # 应用到骨骼
    skeleton.set_bone_pose_rotation(right_arm_bone_id, rotation)
```

**代码位置**：`pet_animation.gd` 第 346-368 行

### 程序化动画类型

| 动画类型 | 实现方式 | 代码位置 |
|---------|---------|---------|
| **wave** | 骨骼旋转 + 整体摆动 | 第 206-211 行 |
| **flip** | 整体旋转 + 跳跃高度 | 第 243-255 行 |
| **spin** | Y 轴旋转 | 第 212-213 行 |
| **fly** | 位置插值 + 悬浮 | 第 217-237 行 |
| **bounce** | 位置弹跳 | 第 214-216 行 |
| **roll** | Z 轴旋转 | 第 238-239 行 |
| **shake** | 位置抖动 | 第 240-242 行 |
| **dance** | 复合动作 | 第 256-260 行 |

### 程序化动画的优势

1. **灵活性**：可以实时调整动画参数
2. **无资源依赖**：不需要预定义动画资源
3. **动态响应**：可以根据游戏状态调整动画
4. **节省内存**：不需要存储大量动画数据

---

## 使用示例

### 示例 1：播放基础移动动画

```gdscript
# 切换到站立状态
animation_module.set_anim_state(PetData.AnimState.IDLE)

# 切换到跑步状态
animation_module.set_anim_state(PetData.AnimState.RUN)
```

### 示例 2：播放程序化动画

```gdscript
# 播放挥手动画
animation_module.switch_anim("wave")

# 播放后空翻
animation_module.switch_anim("flip")
```

### 示例 3：播放任意动画（无需预定义）

```gdscript
# 假设 GLB 模型中有 "punch" 动画
animation_module.switch_anim("punch")

# 假设 GLB 模型中有 "kick" 动画
animation_module.switch_anim("kick")

# 系统会自动识别并播放，无需在场景文件中定义
```

### 示例 4：添加新动画

**步骤 1**：在 GLB 模型中添加动画（如 "dance_special"）

**步骤 2**：在代码中直接使用：

```gdscript
animation_module.switch_anim("dance_special")
```

**完成！** 无需修改场景文件或创建 `AnimationNodeAnimation`。

---

## 总结

### 动画系统架构

1. **基础移动动画** → AnimationTree + BlendTree（平滑过渡）
2. **程序化动画** → 代码生成（灵活动态）
3. **其他动画** → AnimationPlayer 直接播放（无需预定义）

### 关键优势

- ✅ **无需预定义**：非基础动画无需创建 `AnimationNodeAnimation`
- ✅ **无限扩展**：支持任意数量的动画
- ✅ **平滑过渡**：基础移动动画支持平滑混合
- ✅ **灵活动态**：程序化动画可以实时调整
- ✅ **简单维护**：添加新动画只需更新 GLB 模型

### 相关文件

- `scripts/pet_animation.gd` - 动画管理核心逻辑
- `scripts/pet_controller.gd` - 主控制器，初始化动画系统
- `scenes/pet.tscn` - 场景文件，定义 BlendTree 结构
- `scripts/pet_data.gd` - 动画状态枚举定义

---

**最后更新**：2024年
